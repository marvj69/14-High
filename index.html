<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>14-High! (Offline & Online)</title>
    <meta name="description" content="Play the 14-High! card game offline with local storage or online in real-time with Firebase.">
    <meta name="theme-color" content="#4f46e5">
    <link rel="manifest" href="manifest.json"> <!-- Ensure manifest.json exists -->
    <link rel="apple-touch-icon" href="icons/icon-192x192.png"> <!-- Ensure icons exist -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- ALL CSS FROM BOTH VERSIONS MERGED HERE --- */
        /* (Includes styles for both offline and online elements like loading overlays, game IDs, etc.) */
        :root {
          --primary: #4f46e5; /* Indigo */
          --primary-hover: #4338ca;
          --secondary: #14b8a6; /* Teal */
          --success: #22c55e; /* Green */
          --success-hover: #16a34a;
          --danger: #ef4444; /* Red */
          --danger-hover: #dc2626;
          --warning: #f59e0b; /* Amber */
          --light: #ffffff;
          --light-alt: #f9fafb; /* Very light gray */
          --dark: #111827; /* Dark gray */
          --dark-alt: #1f2937; /* Slightly lighter dark gray */
          --gray: #6b7280; /* Medium gray */
          --gray-light: #e5e7eb; /* Light gray */
          --gray-dark: #374151; /* Darker gray */
          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
          --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
          --radius: 0.375rem; /* 6px */
          --transition: all 0.2s ease-in-out;
          --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        /* Dark mode variables */
        [data-theme="dark"] {
          --primary: #6366f1; /* Lighter Indigo */
          --primary-hover: #818cf8;
          --secondary: #2dd4bf; /* Lighter Teal */
          --success: #4ade80; /* Lighter Green */
          --success-hover: #86efac;
          --danger: #f87171; /* Lighter Red */
          --danger-hover: #fda4af;
          --warning: #fbbf24; /* Lighter Amber */
          --light: #121212; /* Dark background */
          --light-alt: #1e1e1e; /* Slightly lighter dark background */
          --dark: #f8fafc; /* Light text */
          --dark-alt: #e2e8f0; /* Slightly darker light text */
          --gray: #94a3b8; /* Lighter gray */
          --gray-light: #2c2c2c; /* Darker borders/dividers */
          --gray-dark: #3a3a3a; /* Even darker elements */
          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
          --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.4), 0 1px 2px -1px rgb(0 0 0 / 0.4);
          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4);
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        body {
            background-color: var(--light-alt); color: var(--dark); font-family: var(--font-sans);
            line-height: 1.6; padding: 1.5rem; min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { max-width: 700px; margin: 0 auto; }
        #app { margin-top: 4rem; }

        /* Typography */
        h1, h2, h3, h4 { font-weight: 600; line-height: 1.3; margin-bottom: 1rem; color: var(--dark); }
        h1 {
            font-size: 2.25rem; font-weight: 700; text-align: center; position: fixed;
            top: 1rem; left: 50%; transform: translateX(-50%); margin: 0; z-index: 900;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            color: var(--primary); width: auto;
        }
        .fixed-header {
            position: fixed; top: 0; left: 0; right: 0; height: 4rem;
            background-color: var(--light-alt); z-index: 800; box-shadow: var(--shadow);
            transition: background-color 0.3s ease;
        }
        [data-theme="dark"] .fixed-header { background-color: var(--light-alt); }
        h2 { font-size: 1.25rem; margin-bottom: 1rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem; color: var(--dark); }
        h3 { font-size: 1rem; margin-bottom: 0.75rem; font-weight: 500; color: var(--gray); }

        /* Card styles */
        .card {
            background-color: var(--light); border-radius: var(--radius); box-shadow: var(--shadow);
            padding: 1.25rem 1.5rem; margin-bottom: 1.5rem; border: 1px solid var(--gray-light);
            transition: var(--transition);
        }
        [data-theme="dark"] .card { background-color: var(--light-alt); border-color: var(--gray-dark); }

        /* Form elements */
        .input-group { display: flex; margin-bottom: 1rem; position: relative; }
        input, button { font-size: 0.9375rem; font-family: inherit; transition: var(--transition); }
        input[type="text"], input[type="number"] {
            flex-grow: 1; padding: 0.625rem 0.875rem; border: 1px solid var(--gray-light);
            border-radius: var(--radius); background-color: var(--light); color: var(--dark);
            outline: none; box-shadow: var(--shadow-sm);
        }
        [data-theme="dark"] input[type="text"], [data-theme="dark"] input[type="number"] {
            background-color: var(--gray-dark); border-color: var(--gray-dark); color: var(--dark);
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--primary); box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        [data-theme="dark"] input[type="text"]:focus, [data-theme="dark"] input[type="number"]:focus {
            border-color: var(--primary); box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }
        input[type="number"] {
            width: 4.5rem; text-align: center; -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .input-with-button { display: flex; width: 100%; }
        .input-with-button input { border-radius: var(--radius) 0 0 var(--radius); border-right: none; }
        button {
            padding: 0.625rem 1rem; border: none; border-radius: var(--radius);
            background-color: var(--primary); color: white; cursor: pointer; font-weight: 500;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.375rem;
            transition: var(--transition); white-space: nowrap;
        }
        button:hover:not(:disabled) { background-color: var(--primary-hover); transform: translateY(-1px); box-shadow: var(--shadow-sm); }
        button:active:not(:disabled) { transform: translateY(0); box-shadow: none; }
        button:disabled { background-color: var(--gray-light); color: var(--gray); cursor: not-allowed; opacity: 0.7; }
        [data-theme="dark"] button:disabled { background-color: var(--gray-dark); color: var(--gray); }
        .btn-add { border-radius: 0 var(--radius) var(--radius) 0; }
        .btn-full { display: block; width: 100%; margin-top: 0.75rem; padding: 0.75rem; }
        .btn-green { background-color: var(--success); }
        .btn-green:hover:not(:disabled) { background-color: var(--success-hover); }
        .btn-red { background-color: var(--danger); }
        .btn-red:hover:not(:disabled) { background-color: var(--danger-hover); }
        .btn-outline { background-color: transparent; border: 1px solid var(--gray-light); color: var(--primary); }
        .btn-outline:hover:not(:disabled) { background-color: rgba(79, 70, 229, 0.05); border-color: var(--primary); }
        [data-theme="dark"] .btn-outline { border-color: var(--gray-dark); color: var(--primary); }
        [data-theme="dark"] .btn-outline:hover:not(:disabled) { background-color: rgba(99, 102, 241, 0.1); border-color: var(--primary); }

        /* Player list */
        .player-list { margin: 0.75rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        .player-item {
            display: flex; justify-content: space-between; align-items: center; background-color: var(--light-alt);
            padding: 0.625rem 1rem; border-radius: var(--radius); border: 1px solid var(--gray-light); transition: var(--transition);
        }
        .player-item span { font-weight: 500; }
        [data-theme="dark"] .player-item { background-color: var(--light); border-color: var(--gray-dark); }
        .btn-remove {
  background: none; color: var(--danger); padding: 0.25rem; border-radius: 50%;
  width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center;
}
.btn-move-up, .btn-move-down {
  background: none;
  color: var(--primary);
  padding: 0.25rem;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  transition: background 0.15s;
}
.btn-move-up:disabled, .btn-move-down:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.btn-move-up:hover:not(:disabled), .btn-move-down:hover:not(:disabled) {
  background: rgba(79, 70, 229, 0.08);
  color: var(--success);
}
        .btn-remove:hover { background: rgba(239, 68, 68, 0.1); color: var(--danger-hover); transform: none; box-shadow: none; }

        /* Tables */
        .table-container { overflow-x: auto; margin-bottom: 1.5rem; border-radius: var(--radius); border: 1px solid var(--gray-light); background-color: var(--light); }
        [data-theme="dark"] .table-container { border-color: var(--gray-dark); }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        [data-theme="dark"] table { background-color: var(--light-alt); }
        th {
            text-align: left; padding: 0.75rem 1rem; background-color: var(--light-alt); font-weight: 500; color: var(--gray);
            text-transform: uppercase; letter-spacing: 0.05em; font-size: 0.75rem; border-bottom: 1px solid var(--gray-light);
        }
        td { padding: 0.875rem 1rem; border-bottom: 1px solid var(--gray-light); vertical-align: middle; color: var(--dark); }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: rgba(79, 70, 229, 0.03); }
        [data-theme="dark"] th { background-color: var(--light); border-bottom-color: var(--gray-dark); color: var(--gray); }
        [data-theme="dark"] td { border-bottom-color: var(--gray-dark); color: var(--dark-alt); }
        [data-theme="dark"] tbody tr:last-child td { border-bottom: none; }
        [data-theme="dark"] tbody tr:hover { background-color: rgba(99, 102, 241, 0.05); }
        td:last-child { font-weight: 600; }
        .winner-row { background-color: rgba(34, 197, 94, 0.05) !important; border-left: 3px solid var(--success); position: relative; }
        .winner-row td:first-child { padding-left: calc(1rem - 3px); }
        [data-theme="dark"] .winner-row { background-color: rgba(74, 222, 128, 0.08) !important; }

        /* Winner display */
        .winner-display {
            margin-bottom: 2rem; text-align: center; background-color: var(--light-alt); padding: 1.5rem;
            border-radius: var(--radius); border: 1px solid var(--gray-light);
        }
        [data-theme="dark"] .winner-display { background-color: var(--dark-alt); border-color: var(--gray-dark); }
        .winner-display h3 { color: var(--gray); margin-bottom: 0.5rem; }
        .winner-name { font-size: 1.5rem; font-weight: 600; color: var(--success); margin-top: 0.25rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .winner-name .fa-crown { color: var(--warning); }

        /* Layout utilities */
        .flex-between { display: flex; justify-content: space-between; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .game-status {
            display: inline-block; font-size: 0.8rem; font-weight: 500; padding: 0.25rem 0.625rem; border-radius: 100px;
            background-color: rgba(79, 70, 229, 0.1); color: var(--primary); margin-bottom: 0.5rem;
        }
        [data-theme="dark"] .game-status { background-color: rgba(99, 102, 241, 0.15); color: var(--primary); }
        .badge { display: inline-block; padding: 0.25rem 0.625rem; border-radius: var(--radius); font-size: 0.8rem; font-weight: 500; margin-left: 0.5rem; }
        .badge-blue { background-color: rgba(79, 70, 229, 0.1); color: var(--primary); }
        .badge-green { background-color: rgba(34, 197, 94, 0.1); color: var(--success); }
        [data-theme="dark"] .badge-blue { background-color: rgba(99, 102, 241, 0.2); }
        [data-theme="dark"] .badge-green { background-color: rgba(74, 222, 128, 0.2); }
        .trick-value { display: flex; align-items: center; justify-content: flex-start; }
        .score-value { font-weight: 600; color: var(--primary); }

        /* Hamburger menu styles */
        .hamburger-menu { position: fixed; top: 1rem; left: 1rem; z-index: 1000; }
        .hamburger-btn, .menu-close {
            background: var(--light); border: 1px solid var(--gray-light); color: var(--gray); cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px;
            border-radius: 50%; transition: var(--transition); padding: 0; font-size: 1rem; box-shadow: var(--shadow);
        }
        .hamburger-btn:hover, .menu-close:hover { background: var(--light-alt); color: var(--primary); transform: scale(1.05); box-shadow: var(--shadow-md); }
        [data-theme="dark"] .hamburger-btn, [data-theme="dark"] .menu-close { background: var(--light); border-color: var(--gray-dark); color: var(--gray); }
        [data-theme="dark"] .hamburger-btn:hover, [data-theme="dark"] .menu-close:hover { background: var(--light-alt); color: var(--primary); }
        .menu-content {
            position: fixed; top: 0; left: -250px; width: 250px; height: 100%; background-color: var(--light);
            box-shadow: var(--shadow-md); transition: left 0.3s ease; padding: 1rem; display: flex; flex-direction: column;
            border-right: 1px solid var(--gray-light); z-index: 1001; /* Ensure menu above overlay */
        }
        [data-theme="dark"] .menu-content { background-color: var(--light-alt); border-right-color: var(--gray-dark); }
        .menu-content.active { left: 0; }
        .menu-header { display: flex; justify-content: flex-end; margin-bottom: 1.5rem; padding-top: 0.5rem; }
        .menu-item-header {
            padding: 0.5rem 0; margin: 1rem 0 0.5rem 0; font-weight: 600; font-size: 0.8rem; color: var(--gray);
            text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid var(--gray-light);
            display: flex; align-items: center; gap: 0.5rem;
        }
        [data-theme="dark"] .menu-item-header { border-color: var(--gray-dark); color: var(--gray); }
        .menu-item {
            padding: 0.75rem 0.5rem; margin: 0.25rem 0; border-radius: var(--radius); cursor: pointer; transition: var(--transition);
            display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;
        }
        .menu-item span { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .menu-item:hover { background-color: var(--light-alt); }
        [data-theme="dark"] .menu-item:hover { background-color: var(--light); }
        .completed-games-list { flex-grow: 1; overflow-y: auto; margin: 0.5rem 0; padding-right: 0.5rem; }
        .completed-games-list::-webkit-scrollbar { width: 6px; }
        .completed-games-list::-webkit-scrollbar-track { background: transparent; }
        .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-light); border-radius: 3px; }
        [data-theme="dark"] .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-dark); }
        .completed-game-item {
            padding: 0.75rem 1rem; margin: 0.5rem 0; background-color: var(--light-alt); border-radius: var(--radius);
            border-left: 3px solid var(--primary); transition: var(--transition); font-size: 0.85rem; cursor: pointer;
        }
        .completed-game-item:hover { transform: translateX(3px); background-color: var(--light); box-shadow: var(--shadow-sm); }
        [data-theme="dark"] .completed-game-item { background-color: var(--gray-dark); border-color: var(--primary); }
        [data-theme="dark"] .completed-game-item:hover { background-color: var(--light-alt); }
        .completed-game-item div { margin: 0.2rem 0; display: flex; align-items: center; gap: 0.5rem; color: var(--gray); }
        .completed-game-item div i { width: 14px; text-align: center; }
        .game-winner { color: var(--success) !important; font-weight: 500; }
        .game-score { color: var(--primary) !important; font-weight: 500; }
        [data-theme="dark"] .game-winner { color: var(--success) !important; }
        [data-theme="dark"] .game-score { color: var(--primary) !important; }
        .no-games { padding: 1rem; text-align: center; color: var(--gray); font-style: italic; font-size: 0.9rem; }

        /* Toggle switch */
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--gray-light); transition: .3s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; box-shadow: var(--shadow-sm); }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }
        [data-theme="dark"] .slider { background-color: var(--gray-dark); }

        /* Game Info / Validation Messages */
        .game-info {
            margin-bottom: 0.75rem; padding: 0.5rem 1rem; background-color: var(--light-alt); border-radius: var(--radius);
            border: 1px solid var(--gray-light); color: var(--gray); font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem; min-height: 36px;
        }
        [data-theme="dark"] .game-info { background-color: var(--light); border-color: var(--gray-dark); }
        .game-info.bid-warning, .game-info.trick-warning { border-left: 3px solid var(--danger); color: var(--danger); background-color: rgba(239, 68, 68, 0.05); }
        [data-theme="dark"] .game-info.bid-warning, [data-theme="dark"] .game-info.trick-warning { background-color: rgba(248, 113, 113, 0.1); }
        .game-info.bid-ok, .game-info.trick-ok { border-left: 3px solid var(--success); color: var(--success); background-color: rgba(34, 197, 94, 0.05); }
        [data-theme="dark"] .game-info.bid-ok, [data-theme="dark"] .game-info.trick-ok { background-color: rgba(74, 222, 128, 0.08); }

        /* Elimination banner */
        .elimination-banner {
            background-color: var(--primary); color: white; padding: 0.2rem 0.5rem; border-radius: var(--radius);
            font-weight: 500; box-shadow: var(--shadow); text-align: center; display: flex; align-items: center; gap: 0.25rem;
            border: 1px solid rgba(0,0,0,0.1); font-size: 0.75rem; white-space: nowrap;
        }
        #elimination-banner { 
            position: fixed; top: 4.5rem; left: 50%; transform: translateX(-50%); z-index: 850; 
            animation: fadeInFixed 0.3s ease-in-out; 
        }
        #round-elimination-banner { 
            z-index: 100; /* Inline banner */
            animation: none; /* Remove animation for inline banner to prevent jerking */
        }
        @keyframes fadeInFixed { from { opacity: 0; transform: translate(-50%, -10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        [data-theme="dark"] .elimination-banner { background-color: var(--primary); color: white; }
        .elimination-banner i { font-size: 0.7rem; }

        .button-group { display: flex; gap: 0.75rem; flex-wrap: wrap; }
        .flex-between > p { color: var(--gray); font-size: 0.9rem; margin-top: 0.25rem; }
        *:focus { outline: none; }
        *:focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; border-radius: var(--radius); }
        input:focus-visible, button:focus-visible, .toggle-switch:focus-within { outline: none; }
        button:focus-visible { box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4); }
        [data-theme="dark"] button:focus-visible { box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5); }

        /* Responsive */
        @media (max-width: 640px) {
            body { padding: 1rem; }
            h1 { font-size: 1.875rem; width: 80%; line-height: 1.2; }
            .card { padding: 1.25rem; }
            .flex-between { flex-direction: column; align-items: stretch; }
            .flex-between > .button-group { width: 100%; justify-content: center; }
            .flex-between > p { text-align: center; width: 100%; margin-top: 0.5rem; }
            th, td { padding: 0.75rem 0.5rem; }
            input[type="number"] { width: 3.8rem; padding: 0.625rem 0.5rem; }
            td { font-size: 0.85rem; }
        }

        /* Touch device hover reset */
        @media (hover: none) {
            button:hover:not(:disabled), .btn-remove:hover, .btn-green:hover:not(:disabled), .btn-red:hover:not(:disabled),
            .btn-outline:hover:not(:disabled), .menu-item:hover, .completed-game-item:hover, .hamburger-btn:hover,
            .menu-close:hover, tbody tr:hover {
                background-color: inherit; color: inherit; transform: none; box-shadow: none; border-color: inherit;
            }
            button:hover:not(:disabled) { background-color: var(--primary); }
            .btn-green:hover:not(:disabled) { background-color: var(--success); }
            .btn-red:hover:not(:disabled) { background-color: var(--danger); }
            .btn-outline:hover:not(:disabled) { background-color: transparent; color: var(--primary); }
            .btn-remove:hover { background: none; color: var(--danger); }
            .completed-game-item:hover { transform: none; background-color: var(--light-alt); }
            [data-theme="dark"] .completed-game-item:hover { background-color: var(--light); }
            [data-theme="dark"] .menu-item:hover { background-color: transparent; }
        }

        /* Version indicator & modal */
        .version-badge {
            position: fixed; top: 1.25rem; right: 1rem; z-index: 900; background-color: var(--light); color: var(--primary);
            border: 1px solid var(--gray-light); border-radius: var(--radius); padding: 0.25rem 0.5rem;
            font-size: 0.75rem; font-weight: 500; box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition);
        }
        .version-badge:hover { background-color: var(--light-alt); box-shadow: var(--shadow); transform: translateY(-2px); }
        .version-modal {
            position: fixed; top: 3.5rem; right: 1rem; z-index: 950; background-color: var(--light);
            border: 1px solid var(--gray-light); border-radius: var(--radius); padding: 1rem; width: 300px;
            max-width: calc(100vw - 2rem); box-shadow: var(--shadow-md); opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0.2s;
        }
        .version-modal.active { opacity: 1; visibility: visible; transform: translateY(0); transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0s; }
        .version-title { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .version-title h3 { margin: 0; color: var(--dark); }
        .version-modal .close-btn {
            background: none; color: var(--gray); padding: 0.25rem; border-radius: 50%; width: 22px; height: 22px; min-width: 22px;
            display: inline-flex; align-items: center; justify-content: center; cursor: pointer; border: none;
        }
        .version-modal .close-btn:hover { color: var(--dark); background-color: var(--gray-light); }
        .version-info { font-size: 0.9rem; color: var(--gray-dark); }
        .version-info p { margin: 0.5rem 0; }
        .version-info ul { margin: 0.5rem 0; padding-left: 1.5rem; }
        .version-info li { margin: 0.25rem 0; }
        [data-theme="dark"] .version-badge { background-color: var(--light-alt); border-color: var(--gray-dark); }
        [data-theme="dark"] .version-badge:hover { background-color: var(--light); }
        [data-theme="dark"] .version-modal { background-color: var(--light-alt); border-color: var(--gray-dark); }
        [data-theme="dark"] .version-modal .close-btn:hover { background-color: var(--gray-dark); color: var(--light); }
        [data-theme="dark"] .version-info { color: var(--dark-alt); }

        /* Eliminated player style */
        .eliminated-player { text-decoration: line-through; opacity: 0.7; color: var(--gray); }
        [data-theme="dark"] .eliminated-player { opacity: 0.6; }

        /* Game Details Modal */
        .game-details-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center; z-index: 1100; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .game-details-modal.active { opacity: 1; visibility: visible; }
        .game-details-content {
            background-color: var(--light); border-radius: var(--radius); width: 90%; max-width: 500px; max-height: 90vh;
            overflow-y: auto; padding: 1.5rem; position: relative; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        [data-theme="dark"] .game-details-content {
            background-color: var(--light-alt);
        }
        .game-details-close {
            position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; color: var(--gray);
            font-size: 1.25rem; transition: color 0.2s ease;
        }
        .game-details-close:hover { color: var(--danger); }

        /* QR Code Modal */
        .qr-code-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center; z-index: 1100; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .qr-code-modal.active { opacity: 1; visibility: visible; }
        .qr-code-content {
            background-color: var(--light); border-radius: var(--radius); width: 90%; max-width: 350px; max-height: 90vh;
            overflow-y: auto; padding: 1.5rem; position: relative; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        [data-theme="dark"] .qr-code-content {
            background-color: var(--light-alt);
        }
        .qr-code-close {
            position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; color: var(--gray);
            font-size: 1.25rem; transition: color 0.2s ease;
        }
        .qr-code-close:hover { color: var(--danger); }
        .qr-code-container {
            margin: 1rem 0;
            display: flex;
            justify-content: center;
        }
        .qr-code-instructions {
            font-size: 0.9rem;
            color: var(--gray);
            margin-top: 1rem;
        }
        .qr-code-content h3 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }
        .qr-code-text {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--primary);
            margin-top: 0.75rem;
            word-break: break-all;
            text-align: center;
        }
        #copy-qr-id-btn {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--success);
            border: none;
            background: none;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        #copy-qr-id-btn:hover {
            color: var(--success-light);
        }

        /* Loading indicator (Online Mode) */
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6);
            color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 1.2rem;
            z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
            text-align: center; padding: 1rem;
        }
        .loading-overlay.active { opacity: 1; visibility: visible; }
        .loading-overlay i { font-size: 2rem; margin-bottom: 1rem; }
        .loading-message { max-width: 80%; }

        /* Dealer/Last Player Indicators (Online Mode) */
        .dealer-indicator { font-size: 0.7rem; font-weight: bold; margin-left: 0.5rem; padding: 0.1rem 0.4rem; border-radius: var(--radius); vertical-align: middle; }
        .dealer-indicator { background-color: rgba(245, 158, 11, 0.1); color: var(--warning); border: 1px solid rgba(245, 158, 11, 0.3); }
        [data-theme="dark"] .dealer-indicator { background-color: rgba(251, 191, 36, 0.2); }
        input.bid-input:disabled { background-color: var(--gray-light); cursor: not-allowed; opacity: 0.7; }
        [data-theme="dark"] input.bid-input:disabled { background-color: var(--gray-dark); }

        /* Game ID display and Join (Online Mode) */
        .game-id-display {
            background-color: var(--light-alt); border: 1px dashed var(--gray-light); border-radius: var(--radius);
            padding: 0.75rem 1rem; margin-bottom: 1rem; font-family: monospace; font-size: 0.9rem; color: var(--primary);
            display: flex; align-items: center; justify-content: space-between; cursor: pointer; transition: background-color 0.2s ease;
            position: relative; text-align: center;
        }
        .game-id-display:hover { 
            background-color: var(--light); 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .game-id-display:after {
            content: 'Click to show QR code';
            display: block;
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            background: var(--bg-color);
            padding: 0 8px;
            color: var(--gray);
            font-family: sans-serif;
        }
        [data-theme="dark"] .game-id-display { background-color: var(--gray-dark); border-color: var(--gray); color: var(--primary); }
        [data-theme="dark"] .game-id-display:hover { background-color: var(--dark-alt); }
        [data-theme="dark"] .game-id-display:after { background-color: var(--dark); }
        .copy-feedback { margin-left: 0.5rem; font-size: 0.8rem; color: var(--success); opacity: 0; transition: opacity 0.3s ease; }
        .copy-feedback.visible { opacity: 1; }
        .divider { text-align: center; margin: 1.5rem 0; color: var(--gray); font-size: 0.9rem; font-weight: 500; display: flex; align-items: center; }
        .divider::before, .divider::after { content: ''; flex-grow: 1; height: 1px; background-color: var(--gray-light); margin: 0 0.5rem; }
        [data-theme="dark"] .divider::before, [data-theme="dark"] .divider::after { background-color: var(--gray-dark); }
        #join-game-id-input { font-family: monospace; text-align: center; /* No uppercase */ }
        .error-message { color: var(--danger); font-size: 0.85rem; margin-top: -0.5rem; margin-bottom: 0.75rem; text-align: center; display: block; min-height: 1.2em; }

        /* Leave/Back Button */
        .btn-leave-game, .btn-back-to-menu {
            background-color: var(--gray); margin-right: 1rem;
        }
        .btn-leave-game:hover:not(:disabled), .btn-back-to-menu:hover:not(:disabled) {
            background-color: var(--gray-dark);
        }
        [data-theme="dark"] .btn-leave-game, [data-theme="dark"] .btn-back-to-menu {
            background-color: var(--gray-dark);
        }
        [data-theme="dark"] .btn-leave-game:hover:not(:disabled), [data-theme="dark"] .btn-back-to-menu:hover:not(:disabled) {
            background-color: var(--gray);
        }

        /* Mode Selection Screen */
        .mode-selection-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            gap: 1.5rem;
        }
        .mode-selection-container .card {
             width: 100%;
             max-width: 400px; /* Limit width of choice cards */
             text-align: center;
        }
         .mode-selection-container .card h3 {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
         }
         .mode-selection-container .card p {
            color: var(--gray);
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            min-height: 3em; /* Ensure cards have similar height */
         }

        /* Button Styles */
        .btn-small {
            background-color: var(--gray-light);
            color: var(--gray);
            border: none;
            border-radius: var(--radius);
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }
        .btn-small:hover {
            background-color: var(--gray);
            color: var(--light);
        }
        [data-theme="dark"] .btn-small {
            background-color: var(--gray-dark);
            color: var(--light);
        }
        [data-theme="dark"] .btn-small:hover {
            background-color: var(--gray);
        }

        /* QR code small button */
        #show-qr-btn {
            padding: 0.5rem 0.7rem;
            font-size: 0.85rem;
            margin-left: 0.5rem;
            height: 2.3rem;
            width: 2.3rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
        }

        /* Text button for copy */
        .btn-text {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--primary);
            transition: color 0.2s ease;
            padding: 0;
            margin: 0;
        }
        .btn-text:hover {
            color: var(--success);
        }
        [data-theme="dark"] .btn-text {
            color: var(--primary-light);
        }
        [data-theme="dark"] .btn-text:hover {
            color: var(--success);
        }

        /* Game Details Modal Content Styles */
        .game-details-content h4 {
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
        }
        .game-date {
            font-size: 0.9rem;
            color: var(--gray);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .winner-names {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--light-alt);
            padding: 0.5rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }
        .winner-names .fa-crown {
            margin-right: 0.5rem;
            color: var(--warning);
        }
        .player-scores-container {
            margin-top: 1rem;
        }
        .player-scores-header {
            display: flex;
            font-weight: 600;
            color: var(--dark-alt);
            border-bottom: 1px solid var(--gray-light);
            padding: 0.5rem 0;
        }
        .player-scores-header span {
            flex: 1;
            text-transform: uppercase;
            font-size: 0.85rem;
        }
        .player-score-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--gray-light);
        }
        .player-score-item:last-child {
            border-bottom: none;
        }
        .player-score-item span {
            flex: 1;
        }
        .player-score-value {
            font-weight: 600;
            color: var(--primary);
            text-align: right;
        }
        .player-score-item.winner {
            background-color: rgba(34, 197, 94, 0.1);
        }
        .player-score-item.eliminated {
            opacity: 0.6;
        }
        [data-theme="dark"] .player-scores-header {
            border-color: var(--gray-dark);
            color: var(--gray);
        }
        [data-theme="dark"] .player-score-item {
            border-color: var(--gray-dark);
        }
        [data-theme="dark"] .player-score-item.winner {
            background-color: rgba(74, 222, 128, 0.1);
        }
    </style>
    <!-- QR Code library (changed to CDN version) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Add html5-qrcode for QR scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
</head>
<body data-theme="light">
    <!-- Game Details Modal -->
    <div id="game-details-modal" class="game-details-modal">
      <div class="game-details-content">
        <button id="game-details-close" class="game-details-close" aria-label="Close game details"><i class="fas fa-times"></i></button>
        <div id="game-details-body"></div>
      </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-code-modal" class="qr-code-modal">
      <div class="qr-code-content">
        <button id="qr-code-close" class="qr-code-close" aria-label="Close QR code"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Game QR Code</h3>
        <div class="qr-code-container" id="qr-code-container"></div>
        <div class="qr-code-text" id="qr-code-text"></div>
        <button id="copy-qr-id-btn" class="btn-text">Copy Game ID</button>
        <div class="qr-code-instructions">
          Other players can scan this QR code with their phone to automatically join your game
        </div>
      </div>
    </div>

    <!-- Hand-off QR Export Modal (for offline game state) -->
    <div id="handoff-qr-modal" class="qr-code-modal">
      <div class="qr-code-content">
        <button id="handoff-qr-close" class="qr-code-close" aria-label="Close hand-off QR"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Hand-off Game (QR)</h3>
        <div class="qr-code-container" id="handoff-qr-container"></div>
        <div class="qr-code-instructions">
          Transfer your offline game to another device by scanning this QR code.<br>
          <span style="font-size:0.85em;color:var(--gray);">Game state is compressed to fit in QR code - round history may be lost.</span>
        </div>
      </div>
    </div>

    <!-- Hand-off QR Import Modal (for scanning QR) -->
    <div id="handoff-import-modal" class="qr-code-modal">
      <div class="qr-code-content" style="max-width:450px;">
        <button id="handoff-import-close" class="qr-code-close" aria-label="Close import QR"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Import Game from QR</h3>
        <div style="font-size: 0.9rem; color: var(--gray); margin-bottom: 1rem; text-align: center;">
          Scan a hand-off QR code from another device.
        </div>
        <div id="handoff-qr-reader" style="width:100%;margin:0 auto;"></div>
        <div id="handoff-import-status" style="margin-top:1rem;color:var(--gray);"></div>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
      <i class="fas fa-spinner fa-spin"></i>
      <div class="loading-message" id="loading-message">Loading...</div>
    </div>

    <div class="fixed-header"></div>
    <div class="hamburger-menu">
        <button class="hamburger-btn" aria-label="Open menu"><i class="fas fa-bars"></i></button>
        <div class="menu-content">
            <div class="menu-header">
                <button class="menu-close" aria-label="Close menu"><i class="fas fa-times"></i></button>
            </div>

            <div class="menu-item-header"><i class="fas fa-cog"></i> Settings</div>
            <div class="menu-item">
                <span><i class="fas fa-moon"></i> Dark Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="dark-mode-toggle" aria-label="Toggle dark mode">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="menu-item menu-item-back-to-menu" id="menu-back-button" style="display: none;">
                 <span><i class="fas fa-arrow-left"></i> Back to Mode Select</span>
            </div>

            <div class="menu-item-header"><i class="fas fa-history"></i> Game History</div>
            <div class="completed-games-list" id="completed-games-list">
                <div class="no-games"><i class="fas fa-info-circle"></i> Loading history...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>14-High!</h1>
        <div id="app">
            <!-- Initial content: Mode Selection Screen -->
            <!-- Will be replaced by JS -->
        </div>
    </div>

    <!-- Elimination notification banner (initially hidden) -->
    <div id="elimination-banner" class="elimination-banner" style="display: none;">
        <i class="fas fa-exclamation-triangle"></i>
        <span id="elimination-message">Upcoming elimination</span>
    </div>

    <!-- Version indicator -->
    <div class="version-badge" id="version-badge">
        <span>v2.1.0</span> <!-- Updated Version -->
    </div>
    <div class="version-modal" id="version-modal">
        <div class="version-title">
            <h3>14-High!</h3>
            <button class="close-btn" id="version-close" aria-label="Close version info">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="version-info">
            <p><strong>Released:</strong> April 2025</p>
            <p><strong>What's New:</strong></p>
            <ul>
                <li><i class="fas fa-compress-alt"></i> **Combined App:** Single page for Offline & Online play!</li>
                <li>Choose your mode on startup.</li>
                <li>Shared UI and core logic.</li>
                <li><i class="fas fa-hdd"></i> Offline mode uses Local Storage.</li>
                <li><i class="fas fa-cloud"></i> Online mode uses Firebase for real-time multiplayer.</li>
                <li>Includes features from both previous versions (history, dark mode, game IDs, etc.).</li>
                <li>Author: Mark Heinonen</li>
                <li>(906) 299-2350</li>

            </ul>
        </div>
    </div>

    <!-- Firebase SDK (Only needed for Online mode) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <script>
        // --- Constants & Config ---
        const MAX_PLAYERS = 56;
        const ELIMINATION_THRESHOLD = 56;
        const LOCAL_STORAGE_OFFLINE_KEY = 'offlineGameState';
        const LOCAL_STORAGE_HISTORY_KEY = 'completedGames'; // Shared history key
        const LOCAL_STORAGE_THEME_KEY = 'theme';
        const DEBOUNCE_DELAY = 300; // Debounce delay in milliseconds for online input
        const RENDER_THROTTLE = 300; // Increased from 150ms to 300ms for smoother rendering
        const FIREBASE_UPDATE_BUFFER = 50; // Additional delay before rendering after Firebase updates

        // IMPORTANT: Replace with your actual Firebase config if using Online mode
        const firebaseConfig = {
          apiKey: "AIzaSyAwrUIh07PQwXP4w_UtA_GWqY1BnI-29fA",
          authDomain: "asphalt-yield-calculator.firebaseapp.com",
          databaseURL: "https://asphalt-yield-calculator-default-rtdb.firebaseio.com",
          projectId: "asphalt-yield-calculator",
          storageBucket: "asphalt-yield-calculator.firebasestorage.app",
          messagingSenderId: "976877514620",
          appId: "1:976877514620:web:cc15b1bdaf19c4a53b7ef9",
          measurementId: "G-NM5V8EXM44"
        };

        // --- Global State ---
        let currentMode = 'entry'; // 'entry', 'offline', 'online-entry', 'online-game'
        let offlineState = {};
        let onlineState = {}; // Cache of Firebase data for the current game
        let currentGameId = null; // Online mode: ID of the current Firebase game
        let gameRef = null; // Online mode: Firebase reference to the current game
        let gameListenerHandle = null; // Online mode: Firebase listener handle
        let localHistory = []; // Shared completed games history
        let firebaseInitialized = false;
        let firebaseConnected = false;
        let initialConnectionEstablished = false;
        let previousHtml = ''; // Track previous HTML for diffing
        let darkMode = false;
        let pendingUpdates = {}; // Store pending Firebase updates
        let debounceTimers = {}; // Store debounce timers
        let lastRenderTime = 0; // Track last render time for throttling
        let pendingRender = false; // Track if render is pending

        // --- DOM Elements ---
        const app = document.getElementById('app');
        const hamburgerBtn = document.querySelector('.hamburger-btn');
        const menuContent = document.querySelector('.menu-content');
        const menuClose = document.querySelector('.menu-close');
        const menuBackButton = document.getElementById('menu-back-button');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const completedGamesList = document.getElementById('completed-games-list');
        const body = document.body;
        const versionBadge = document.getElementById('version-badge');
        const versionModal = document.getElementById('version-modal');
        const versionClose = document.getElementById('version-close');
        const eliminationBanner = document.getElementById('elimination-banner');
        const loadingOverlay = document.getElementById('loading-overlay');
        const gameDetailsModal = document.getElementById('game-details-modal');
        const gameDetailsClose = document.getElementById('game-details-close');
        const gameDetailsBody = document.getElementById('game-details-body');

        // --- Initialization ---
        function initializeApp() {
            // Load theme preference
            const savedTheme = localStorage.getItem(LOCAL_STORAGE_THEME_KEY);
            if (savedTheme === 'dark') {
                darkMode = true;
                document.body.setAttribute('data-theme', 'dark');
                if (darkModeToggle) darkModeToggle.checked = true;
            }

            // Load completed games history
            loadLocalHistory();

            // Initialize Firebase if Online mode
            if (window.location.search.includes('game=')) {
                // When launched via QR code with game parameter, go straight to online mode
                selectMode('online');
                // joinOnlineGame will handle the URL parameter automatically
            } else {
                // Normal startup - render initial screen
                renderApp();
            }

            // Set up click handlers (Delegated)
            app.addEventListener('click', handleAppClick);
            document.body.addEventListener('keypress', handleAppKeyPress);
            app.addEventListener('input', handleAppInput);

            // Menu and mode select handlers
            hamburgerBtn.addEventListener('click', () => menuContent.classList.add('active'));
            menuClose.addEventListener('click', () => menuContent.classList.remove('active'));
            gameDetailsClose.addEventListener('click', closeGameDetailsModal);
            gameDetailsModal.addEventListener('click', (e) => {
                if (e.target === gameDetailsModal) closeGameDetailsModal();
            });
            // Dark mode toggle
            darkModeToggle.addEventListener('change', () => {
                darkMode = darkModeToggle.checked;
                document.body.setAttribute('data-theme', darkMode ? 'dark' : 'light');
                localStorage.setItem(LOCAL_STORAGE_THEME_KEY, darkMode ? 'dark' : 'light');
            });

            // Menu back button
            menuBackButton.addEventListener('click', goBackToEntry);

            // Completed games list item click
            completedGamesList.addEventListener('click', (e) => {
                const gameItem = e.target.closest('.completed-game-item');
                if (gameItem) {
                    const gameIndex = parseInt(gameItem.getAttribute('data-game-index'));
                    if (!isNaN(gameIndex)) showGameDetails(gameIndex);
                }
            });

            // Check for elimination warning for online games
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && currentMode === 'online-game' && onlineState.gameStarted) {
                    // Re-check elimination warning when tab becomes visible
                     checkUpcomingElimination(onlineState);
                }
            });

            // Elimination banner dismiss
            if (eliminationBanner) {
                eliminationBanner.addEventListener('click', (e) => {
                    if (e.target.closest('.elimination-dismiss')) {
                        eliminationBanner.style.display = 'none';
                    }
                });
            }
            
            // Bind common UI event handlers (version badge, escape key, modal clicks)
            setupCommonEventListeners();

            // Hand-off QR event listeners
            document.body.addEventListener('click', function(e) {
                // Export (Hand-off via QR)
                if (e.target.closest('#handoff-qr-btn')) {
                    showHandoffQRModal();
                }
                // Import (Scan QR)
                if (e.target.closest('#handoff-import-btn')) {
                    showHandoffImportModal();
                }
            });
        }

        function setupCommonEventListeners() {
            // Hamburger menu
            hamburgerBtn.addEventListener('click', () => menuContent.classList.add('active'));
            menuClose.addEventListener('click', () => menuContent.classList.remove('active'));
            document.addEventListener('click', (e) => {
                if (menuContent.classList.contains('active') && !menuContent.contains(e.target) && !hamburgerBtn.contains(e.target)) {
                    menuContent.classList.remove('active');
                }
                if (versionModal.classList.contains('active') && !versionModal.contains(e.target) && !versionBadge.contains(e.target)) {
                    versionModal.classList.remove('active');
                }
                if (gameDetailsModal.classList.contains('active') && e.target === gameDetailsModal) {
                    closeGameDetailsModal();
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (menuContent.classList.contains('active')) menuContent.classList.remove('active');
                    if (versionModal.classList.contains('active')) versionModal.classList.remove('active');
                    if (gameDetailsModal.classList.contains('active')) closeGameDetailsModal();
                }
            });
            menuBackButton.addEventListener('click', goBackToEntry);

            // Dark mode
            darkModeToggle.addEventListener('change', () => applyTheme(darkModeToggle.checked ? 'dark' : 'light'));

            // Version modal
            versionBadge.addEventListener('click', (e) => { e.stopPropagation(); versionModal.classList.add('active'); });
            versionClose.addEventListener('click', () => versionModal.classList.remove('active'));

            // Game details modal
            gameDetailsClose.addEventListener('click', closeGameDetailsModal);
            completedGamesList.addEventListener('click', (e) => {
                const gameItem = e.target.closest('.completed-game-item');
                if (gameItem) {
                    const gameIndex = parseInt(gameItem.getAttribute('data-game-index'));
                    if (!isNaN(gameIndex)) showGameDetails(gameIndex);
                }
            });

            // Main app container for dynamic elements
            app.addEventListener('click', handleAppClick);
            app.addEventListener('keypress', handleAppKeyPress);
            app.addEventListener('input', handleAppInput);
            app.addEventListener('focusin', (e) => {
                if (e.target.matches('input[type="number"]') || e.target.matches('input[type="text"]')) {
                    e.target.select();
                }
            });
        }

        // --- Mode Selection & Switching ---
        function selectMode(mode) {
            console.log("Selecting mode:", mode);
            hideEliminationBanner();
            if (mode === 'offline') {
                currentMode = 'offline';
                loadOfflineState();
                menuBackButton.style.display = 'block';
                renderApp();
            } else if (mode === 'online') {
                currentMode = 'online-entry'; // Go to the online create/join screen
                initializeFirebaseIfNeeded(); // Initialize FB now
                menuBackButton.style.display = 'block';
                renderApp();
            } else { // Go back to entry
                currentMode = 'entry';
                detachGameListener(); // Clean up online stuff if any
                offlineState = {}; // Clear offline state
                onlineState = {}; // Clear online cache
                currentGameId = null;
                menuBackButton.style.display = 'none';
                renderApp();
            }
        }

        // Check if there's a saved offline game in localStorage
        function hasSavedOfflineGame() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (!savedState) return false;
            
            try {
                const state = JSON.parse(savedState);
                // Check if the game was actually started and has players
                return state.gameStarted && state.players && state.players.length >= 2;
            } catch (err) {
                console.error('Error checking saved offline game:', err);
                return false;
            }
        }

        function goBackToEntry() {
            if (currentMode === 'online-game' || currentMode === 'online-entry') {
                 if (currentMode === 'online-game' && confirm("Are you sure you want to leave this online game?")) {
                     leaveOnlineGame(false); // Leave without rendering entry screen yet
                     selectMode('entry'); // Now render entry screen
                 } else if (currentMode === 'online-entry') {
                     selectMode('entry'); // Just go back if on create/join screen
                 }
            } else if (currentMode === 'offline') {
                 if (offlineState.gameStarted && confirm("Are you sure you want to leave this offline game? Progress might be saved.")) {
                    selectMode('entry');
                 } else if (!offlineState.gameStarted) {
                    selectMode('entry');
                 }
            }
            menuContent.classList.remove('active'); // Close menu after action
        }

        // --- Firebase Initialization and Connection (Online Mode) ---
        function initializeFirebaseIfNeeded() {
            if (firebaseInitialized) return;
            try {
                console.log("Initializing Firebase...");
                firebase.initializeApp(firebaseConfig);
                firebaseInitialized = true;
                monitorFirebaseConnection();
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                alert("Failed to initialize online services. Please check configuration or try offline mode.");
                currentMode = 'entry'; // Fallback to entry screen
            }
        }

        function monitorFirebaseConnection() {
            const database = firebase.database();
            database.ref(".info/connected").on("value", (snap) => {
                if (snap.val() === true) {
                    console.log("Firebase connected.");
                    firebaseConnected = true;
                    initialConnectionEstablished = true;
                    if (currentMode === 'online-entry' || currentMode === 'online-game') {
                        setLoading(false);
                        if (currentMode === 'online-game' && !gameListenerHandle) {
                            // Re-attach listener if we reconnected while in a game
                            attachGameListener(currentGameId);
                        } else if (currentMode === 'online-entry') {
                            renderApp(); // Re-render entry screen if needed
                        }
                    }
                } else {
                    console.log("Firebase disconnected.");
                    firebaseConnected = false;
                    if (currentMode === 'online-entry' || currentMode === 'online-game') {
                        if (initialConnectionEstablished) {
                            setLoading(true, '<i class="fas fa-wifi"></i> Connection lost. Reconnecting...');
                        } else {
                            setLoading(true, 'Connecting to online services...');
                        }
                    }
                }
            });
        }

        // --- Event Handlers (Delegated) ---
        function handleAppClick(e) {
            const target = e.target;

            // Mode Selection Screen Actions
            if (target.closest('#select-offline-btn')) { selectMode('offline'); return; }
            if (target.closest('#select-online-btn')) { selectMode('online'); return; }

            // Online Mode Actions
            if (currentMode === 'online-entry') {
                if (target.closest('#create-game-btn')) { createOnlineGame(); return; }
                if (target.closest('#join-game-btn')) { joinOnlineGame(); return; }
            }

            // In-Game Actions (Check current mode)
            if (currentMode === 'offline' || currentMode === 'online-game') {
                // Player Setup (only if game not started)
                const currentState = (currentMode === 'offline') ? offlineState : onlineState;
                if (!currentState.gameStarted) {
                    if (target.closest('#add-player-btn')) {
                        currentMode === 'offline' ? addPlayerOffline() : addPlayerOnline();
                        return;
                    }
                    const removeBtn = target.closest('.btn-remove');
                    if (removeBtn) {
                        const player = removeBtn.getAttribute('data-player');
                        if (player) currentMode === 'offline' ? removePlayerOffline(player) : removePlayerOnline(player);
                        return;
                    }
                    const moveUpBtn = target.closest('.btn-move-up');
                    if (moveUpBtn) {
                        const player = moveUpBtn.getAttribute('data-player');
                        if (player) {
                            if (currentMode === 'offline') {
                                const idx = offlineState.players.indexOf(player);
                                if (idx > 0) {
                                    [offlineState.players[idx - 1], offlineState.players[idx]] = [offlineState.players[idx], offlineState.players[idx - 1]];
                                    saveOfflineState();
                                    renderApp();
                                }
                            } else {
                                // Online: update Firebase
                                const idx = onlineState.players.indexOf(player);
                                if (idx > 0) {
                                    const newPlayers = [...onlineState.players];
                                    [newPlayers[idx - 1], newPlayers[idx]] = [newPlayers[idx], newPlayers[idx - 1]];
                                    gameRef.update({ '/players': newPlayers });
                                }
                            }
                        }
                        return;
                    }
                    const moveDownBtn = target.closest('.btn-move-down');
                    if (moveDownBtn) {
                        const player = moveDownBtn.getAttribute('data-player');
                        if (player) {
                            if (currentMode === 'offline') {
                                const idx = offlineState.players.indexOf(player);
                                if (idx !== -1 && idx < offlineState.players.length - 1) {
                                    [offlineState.players[idx + 1], offlineState.players[idx]] = [offlineState.players[idx], offlineState.players[idx + 1]];
                                    saveOfflineState();
                                    renderApp();
                                }
                            } else {
                                // Online: update Firebase
                                const idx = onlineState.players.indexOf(player);
                                if (idx !== -1 && idx < onlineState.players.length - 1) {
                                    const newPlayers = [...onlineState.players];
                                    [newPlayers[idx + 1], newPlayers[idx]] = [newPlayers[idx], newPlayers[idx + 1]];
                                    gameRef.update({ '/players': newPlayers });
                                }
                            }
                        }
                        return;
                    }
                    if (target.closest('#start-game-btn')) {
                        currentMode === 'offline' ? startGameOffline() : startGameOnline();
                        return;
                    }
                }
                // Gameplay Actions (only if game started)
                if (currentState.gameStarted) {
                    if (target.closest('#submit-bids-btn')) {
                        currentMode === 'offline' ? submitBidsOffline() : submitBidsOnline();
                        return;
                    }
                    if (target.closest('#submit-results-btn')) {
                        currentMode === 'offline' ? submitRoundResultsOffline() : submitRoundResultsOnline();
                        return;
                    }
                    if (target.closest('#reset-game-btn')) {
                        currentMode === 'offline' ? resetGameOffline() : resetGameOnline();
                        return;
                    }
                    if (target.closest('#undo-round-btn') && currentMode === 'offline') { // Undo only makes sense offline
                        undoRoundOffline();
                        return;
                    }
                    // Leave/Back handled by menu or specific buttons
                    if (target.closest('#leave-game-btn')) {
                         goBackToEntry(); // Use centralized back logic
                         return;
                    }
                     if (target.closest('#back-to-menu-btn')) {
                         goBackToEntry(); // Use centralized back logic
                         return;
                    }
                }
            }

            // QR code button
            if (target.closest('#show-qr-btn') && currentMode === 'online-game' && currentGameId) {
                showQRCode(currentGameId);
                return;
            }

            // Game ID Copy (Online Mode)
            const gameIdDisplay = target.closest('.game-id-display');
            if (gameIdDisplay && (currentMode === 'online-game' || currentMode === 'online-entry')) {
                const gameId = gameIdDisplay.getAttribute('data-game-id');
                if (gameId) {
                    // Show QR code for the entire game-id-display
                    showQRCode(gameId);
                }
            }
            
            // Copy button
            const copyBtn = target.closest('.copy-id-btn');
            if (copyBtn) {
                const gameId = copyBtn.getAttribute('data-game-id');
                if (gameId) {
                    const feedbackId = currentMode === 'online-game' ? 
                        `copy-feedback-gameplay-${gameId}` : `copy-feedback-${gameId}`;
                    const feedbackEl = document.getElementById(feedbackId);
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(gameId).then(() => {
                        if (feedbackEl) {
                            feedbackEl.classList.add('visible');
                            setTimeout(() => feedbackEl.classList.remove('visible'), 1500);
                        }
                    }).catch(err => { 
                        console.error('Failed to copy:', err); 
                        alert('Copy failed.'); 
                    });
                }
            }
        }

        function handleAppKeyPress(e) {
            if (e.key !== 'Enter') return;

            // Online Join on Enter
            if (currentMode === 'online-entry' && e.target.id === 'join-game-id-input') {
                e.preventDefault();
                joinOnlineGame();
                return;
            }

            // In-Game Enter Key Actions
             if ((currentMode === 'offline' || currentMode === 'online-game')) {
                 const currentState = (currentMode === 'offline') ? offlineState : onlineState;
                 const activePlayer = (currentMode === 'offline') ? e.target.getAttribute('data-player') : e.target.getAttribute('data-player'); // Assuming same attribute name

                 // Add Player on Enter
                 if (!currentState.gameStarted && e.target.id === 'player-name') {
                     e.preventDefault();
                     currentMode === 'offline' ? addPlayerOffline() : addPlayerOnline();
                     return;
                 }

                 // Bid/Trick Input Navigation/Submission
                 if (currentState.gameStarted) {
                    const bidInput = e.target.closest('.bid-input');
                    const trickInput = e.target.closest('.trick-input');

                    if (bidInput && currentState.bidPhase && !bidInput.disabled) {
                        e.preventDefault();
                         // Focus next enabled input or submit if last
                        const allEnabledBidInputs = Array.from(app.querySelectorAll('.bid-input:not([disabled])'));
                        const currentIndex = allEnabledBidInputs.findIndex(input => input === bidInput);
                        const nextInput = allEnabledBidInputs[currentIndex + 1];

                        if (nextInput) {
                            nextInput.focus();
                            nextInput.select();
                        } else if (allBidsEntered(currentState)) {
                           currentMode === 'offline' ? submitBidsOffline() : submitBidsOnline();
                        }
                    } else if (trickInput && !currentState.bidPhase) {
                         e.preventDefault();
                         // Focus next input or submit if last
                         const allTrickInputs = Array.from(app.querySelectorAll('.trick-input'));
                         const currentIndex = allTrickInputs.findIndex(input => input === trickInput);
                         const nextInput = allTrickInputs[currentIndex + 1];

                         if (nextInput) {
                             nextInput.focus();
                             nextInput.select();
                         } else if (allTricksEntered(currentState) && validateTricksTotal(currentState)) {
                             currentMode === 'offline' ? submitRoundResultsOffline() : submitRoundResultsOnline();
                         }
                    }
                 }
             }
        }

        // Add debounce function to prevent excessive Firebase updates
        function debounce(func, delay, key) {
            return function(...args) {
                if (debounceTimers[key]) {
                    clearTimeout(debounceTimers[key]);
                }
                debounceTimers[key] = setTimeout(() => {
                    func.apply(this, args);
                    delete debounceTimers[key];
                }, delay);
            };
        }

        // Add throttle function to prevent excessive rendering
        function throttledRender() {
            const now = Date.now();
            if (now - lastRenderTime >= RENDER_THROTTLE) {
                renderApp();
                lastRenderTime = now;
                pendingRender = false;
            } else if (!pendingRender) {
                pendingRender = true;
                setTimeout(() => {
                    // Only render if no more updates have come in during the wait
                    if (pendingRender) {
                        renderApp();
                        lastRenderTime = Date.now();
                        pendingRender = false;
                    }
                }, RENDER_THROTTLE - (now - lastRenderTime));
            }
        }

        function handleAppInput(e) {
            const target = e.target;

            // Offline Input Handling
            if (currentMode === 'offline') {
                 const bidInput = target.closest('.bid-input');
                 const trickInput = target.closest('.trick-input');
                 if (bidInput && offlineState.gameStarted && offlineState.bidPhase) {
                     const player = bidInput.getAttribute('data-player');
                     const value = bidInput.value;
                     if (player) handleBidChangeOffline(player, value);
                 } else if (trickInput && offlineState.gameStarted && !offlineState.bidPhase) {
                     const player = trickInput.getAttribute('data-player');
                     const value = trickInput.value;
                     if (player) handleTricksChangeOffline(player, value);
                 }
            }
            // Online Input Handling (Write to Firebase) - Now with debouncing
            else if (currentMode === 'online-game') {
                const bidInput = target.closest('.bid-input');
                const trickInput = target.closest('.trick-input');
                
                if (bidInput && onlineState.gameStarted && onlineState.bidPhase && !bidInput.disabled && gameRef) {
                    const player = bidInput.getAttribute('data-player');
                    const value = bidInput.value;
                    const bidValue = value === '' ? null : parseInt(value);

                    if (player && bidValue !== undefined) { // Ensure player exists and value is parseable or null
                        if (bidValue !== null && (isNaN(bidValue) || bidValue < 0 || bidValue > onlineState.currentRound)) {
                            // Simple client-side validation before write
                            bidInput.value = onlineState.bids[player] ?? ''; // Revert UI immediately
                            return;
                        }
                        // Dealer check *before* writing
                        if (isDealer(player, onlineState)) {
                            const potentialTotal = calculatePotentialBidTotal(player, bidValue, onlineState);
                            if (potentialTotal === onlineState.currentRound) {
                                updateValidationAndButtons(); // Show warning but don't write
                                return;
                            }
                        }
                        
                        // Store data locally first for immediate feedback BUT DON'T RENDER YET
                        if (!onlineState.bids) onlineState.bids = {};
                        onlineState.bids[player] = bidValue;
                        updateValidationAndButtons(); // Update UI hints immediately without full rerender
                        
                        // Debounce Firebase update
                        const updateBid = debounce((playerName, value) => {
                            gameRef.child('bids').child(playerName).set(value)
                               .catch(err => console.error(`Firebase bid write failed:`, err));
                        }, DEBOUNCE_DELAY, `bid-${player}`);
                        
                        updateBid(player, bidValue);
                    }
                } else if (trickInput && onlineState.gameStarted && !onlineState.bidPhase && gameRef) {
                    const player = trickInput.getAttribute('data-player');
                    const value = trickInput.value;
                    const tricksValue = value === '' ? null : parseInt(value);

                    if (player && tricksValue !== undefined) {
                        if (tricksValue !== null && (isNaN(tricksValue) || tricksValue < 0 || tricksValue > 14)) {
                            trickInput.value = onlineState.tricks[player] ?? ''; // Revert UI immediately
                            return;
                        }
                        
                        // Store data locally first for immediate feedback BUT DON'T RENDER YET
                        if (!onlineState.tricks) onlineState.tricks = {};
                        onlineState.tricks[player] = tricksValue;
                        updateValidationAndButtons(); // Update UI hints immediately without full rerender
                        
                        // Debounce Firebase update
                        const updateTrick = debounce((playerName, value) => {
                            gameRef.child('tricks').child(playerName).set(value)
                               .catch(err => console.error(`Firebase trick write failed:`, err));
                        }, DEBOUNCE_DELAY, `trick-${player}`);
                        
                        updateTrick(player, tricksValue);
                    }
                }
            }
        }

        // --- Core Rendering Logic ---
        function renderApp() {
            let newHtml = '';
            let currentState = {};

            if (currentMode === 'entry') {
                newHtml = renderEntryScreen();
            } else if (currentMode === 'offline') {
                currentState = offlineState;
                if (!currentState.gameStarted) newHtml = renderPlayerSetup(currentState, 'offline');
                else newHtml = renderGameplay(currentState, 'offline');
            } else if (currentMode === 'online-entry') {
                newHtml = renderOnlineEntryScreen();
            } else if (currentMode === 'online-game') {
                currentState = onlineState;
                 if (Object.keys(currentState).length === 0 && currentGameId) { // Still loading FB data
                    newHtml = renderLoadingGameScreen();
                 } else if (!currentState.gameStarted) {
                    newHtml = renderPlayerSetup(currentState, 'online');
                 } else {
                    newHtml = renderGameplay(currentState, 'online');
                 }
            } else {
                newHtml = '<div class="card"><p>Error: Invalid application state.</p></div>';
            }

            // Don't rerender if the HTML hasn't changed - prevents jitter
            if (newHtml === previousHtml) {
                return;
            }
            
            // More efficient DOM update strategy to minimize flicker
            // Create a temporary div to parse the HTML
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = newHtml;
            
            // Cache active element before DOM update
            const activeElement = document.activeElement;
            const activeId = activeElement ? activeElement.id : null;
            const activeDataPlayer = activeElement ? activeElement.getAttribute('data-player') : null;
            const activeSelectionStart = activeElement && 'selectionStart' in activeElement ? activeElement.selectionStart : null;
            const activeSelectionEnd = activeElement && 'selectionEnd' in activeElement ? activeElement.selectionEnd : null;
            
            // Update the DOM
            app.innerHTML = newHtml;
            previousHtml = newHtml;
            
            // Try to restore focus with selection if possible
            if (activeId) {
                const newActiveElement = document.getElementById(activeId);
                if (newActiveElement) {
                    newActiveElement.focus();
                    if (activeSelectionStart !== null && activeSelectionEnd !== null && 'selectionStart' in newActiveElement) {
                        newActiveElement.selectionStart = activeSelectionStart;
                        newActiveElement.selectionEnd = activeSelectionEnd;
                    }
                }
            } else if (activeDataPlayer) {
                const newActiveElements = document.querySelectorAll(`[data-player="${activeDataPlayer}"]`);
                if (newActiveElements.length > 0) {
                    newActiveElements[0].focus();
                    if (activeSelectionStart !== null && activeSelectionEnd !== null && 'selectionStart' in newActiveElements[0]) {
                        newActiveElements[0].selectionStart = activeSelectionStart;
                        newActiveElements[0].selectionEnd = activeSelectionEnd;
                    }
                }
            }
            
            applyPostRenderFocus(currentState);

            // Always update validation/buttons after render, especially for online mode updates
            if (currentMode === 'offline' || currentMode === 'online-game') {
                 updateValidationAndButtons();
                 if (currentState.gameStarted && currentState.currentRound <= 14) {
                    setTimeout(() => checkUpcomingElimination(currentState), 0);
                 }
            }
        }

        function applyPostRenderFocus(currentState) {
            // Preserve the currently focused element
            const activeElementId = document.activeElement ? document.activeElement.id : '';
            const activeElementSelector = document.activeElement ? 
                (document.activeElement.getAttribute('data-player') ? 
                    `.${document.activeElement.classList[0]}[data-player="${document.activeElement.getAttribute('data-player')}"]` : 
                    '') : 
                '';
            const hadFocus = document.activeElement && 
                (document.activeElement.classList.contains('bid-input') || 
                 document.activeElement.classList.contains('trick-input'));
            const selectionStart = hadFocus ? document.activeElement.selectionStart : null;
            const selectionEnd = hadFocus ? document.activeElement.selectionEnd : null;

            // Try to restore focus to the same element
            if (hadFocus && activeElementSelector) {
                const elementToFocus = document.querySelector(activeElementSelector);
                if (elementToFocus) {
                    elementToFocus.focus();
                    if (selectionStart !== null && selectionEnd !== null) {
                        elementToFocus.selectionStart = selectionStart;
                        elementToFocus.selectionEnd = selectionEnd;
                    } else {
                        elementToFocus.select();
                    }
                    return; // Exit early - we've restored focus
                }
            } else if (activeElementId) {
                const elementToFocus = document.getElementById(activeElementId);
                if (elementToFocus) {
                    elementToFocus.focus();
                    return; // Exit early - we've restored focus
                }
            }
            
            // Default focus behavior if we can't restore previous focus
            if (currentMode === 'entry') {
                 const offlineBtn = document.getElementById('select-offline-btn');
                 if (offlineBtn) offlineBtn.focus();
            } else if (currentMode === 'online-entry') {
                 const joinInput = document.getElementById('join-game-id-input');
                 if (joinInput) joinInput.focus();
            } else if (currentMode === 'offline' || currentMode === 'online-game') {
                 if (!currentState.gameStarted) {
                    const playerNameInput = document.getElementById('player-name');
                    if (playerNameInput) playerNameInput.focus();
                 } else if (currentState.bidPhase && currentState.currentRound <= 14) {
                    const firstInput = document.querySelector('.bid-input:not([disabled])'); // Focus first *enabled* bid input
                    if (firstInput && (firstInput.value === '' || firstInput.value === null)) firstInput.focus();
                 } else if (!currentState.bidPhase && currentState.currentRound <= 14) {
                    const firstInput = document.querySelector('.trick-input');
                    if (firstInput && (firstInput.value === '' || firstInput.value === null)) firstInput.focus();
                 }
            }
            
            // Ensure back-to-menu button has a direct event listener as a fallback
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            if (backToMenuBtn) {
                // Remove any existing listeners to prevent duplicates
                backToMenuBtn.removeEventListener('click', goBackToEntry);
                // Add a fresh listener
                backToMenuBtn.addEventListener('click', goBackToEntry);
            }
        }

        function updateValidationAndButtons() {
            const state = (currentMode === 'offline') ? offlineState : onlineState;
            if (!state || !state.gameStarted || state.currentRound > 14) return; // Only run if in a started game

            const totalBids = calculateTotalBids(state.bids, state.players);
            const totalTricks = calculateTotalTricks(state.tricks, state.players);
            const dealerName = (currentMode === 'online-game') ? getDealerName(state) : null; // Only relevant online
            const dealerBid = (dealerName && state.bids && state.bids[dealerName] !== undefined && state.bids[dealerName] !== null) ? state.bids[dealerName] : undefined;
            const players = state.players || [];

            // --- Update Bid Info/Warning ---
            const bidInfoEl = document.getElementById('bid-info');
            if (bidInfoEl && state.bidPhase) {
                if (allPlayersHaveBid(state)) {
                    if (totalBids === state.currentRound) {
                        bidInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total bids cannot equal ${state.currentRound} (currently ${totalBids}). ${dealerName ? escapeHtml(dealerName) + ' must change bid.' : ''}`;
                        bidInfoEl.className = 'game-info bid-warning';
                    } else {
                        bidInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Bids: Total ${totalBids}`;
                        bidInfoEl.className = 'game-info bid-ok';
                    }
                } else {
                    const waitingFor = players.filter(p => !state.bids || state.bids[p] === undefined || state.bids[p] === null);
                    const waitingText = waitingFor.length > 0 ? ` Waiting for ${waitingFor.length > 2 ? waitingFor.length + ' players' : waitingFor.map(escapeHtml).join(' & ')}.` : '';
                    bidInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total bids: ${totalBids} / ${state.currentRound}.${waitingText}`;
                    bidInfoEl.className = 'game-info';
                }
            }

            // --- Update Trick Info/Warning ---
            const trickInfoEl = document.getElementById('trick-info');
            if (trickInfoEl && !state.bidPhase) {
                if (allPlayersHaveTricks(state)) {
                    if (totalTricks !== state.currentRound) {
                        trickInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total hands must equal ${state.currentRound} (currently ${totalTricks})`;
                        trickInfoEl.className = 'game-info trick-warning';
                    } else {
                        trickInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Hands: Total ${totalTricks}`;
                        trickInfoEl.className = 'game-info trick-ok';
                    }
                } else {
                    const waitingFor = players.filter(p => !state.tricks || state.tricks[p] === undefined || state.tricks[p] === null);
                    const waitingText = waitingFor.length > 0 ? ` Waiting for ${waitingFor.length > 2 ? waitingFor.length + ' players' : waitingFor.map(escapeHtml).join(' & ')}.` : '';
                    trickInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total hands: ${totalTricks} / ${state.currentRound}.${waitingText}`;
                    trickInfoEl.className = 'game-info';
                }
            }

            // --- Update Button States ---
            const submitBidsBtn = document.getElementById('submit-bids-btn');
            if (submitBidsBtn) {
                submitBidsBtn.disabled = !allBidsEntered(state);
            }
            const submitResultsBtn = document.getElementById('submit-results-btn');
            if (submitResultsBtn) {
                submitResultsBtn.disabled = !(allTricksEntered(state) && validateTricksTotal(state));
            }
        }

        // --- Rendering Components ---

        function renderEntryScreen() {
            // Check if there's a saved offline game
            const hasSavedGame = hasSavedOfflineGame();
            const offlineButtonText = hasSavedGame ? 
                `<i class="fas fa-undo"></i> Continue Offline Game` : 
                `<i class="fas fa-play"></i> Start Offline Game`;
            
            return `
                <div class="card mode-selection-container">
                    <h2><i class="fas fa-dice"></i> Choose Your Game Mode</h2>
                    <div class="card">
                        <h3><i class="fas fa-user-friends"></i> Play Offline</h3>
                        <p>Play solo or pass the device around. Game progress is saved locally in your browser.</p>
                        <button id="select-offline-btn" class="btn-full">${offlineButtonText}</button>
                        <button id="handoff-import-btn" class="btn-small" style="margin-top:0.5rem;"><i class="fas fa-qrcode"></i> Import from QR</button>
                    </div>
                    <div class="card">
                        <h3><i class="fas fa-globe-americas"></i> Play Online</h3>
                        <p>Create or join a game room to play with friends in real-time. Requires internet connection.</p>
                        <button id="select-online-btn" class="btn-full btn-green"><i class="fas fa-wifi"></i> Go Online</button>
                    </div>
                </div>
            `;
        }

        function renderOnlineEntryScreen() {
            // Same as the previous online version's entry screen
            return `
            <div class="card">
                <h2><i class="fas fa-door-open"></i> Online: Join or Create Game</h2>
                <p style="color: var(--gray); margin-bottom: 1.5rem; text-align: center;">Create a new game room or enter the ID of an existing one.</p>

                 <div class="card" style="background-color: var(--light-alt);">
                     <h3><i class="fas fa-plus-circle"></i> Create New Game</h3>
                     <p style="font-size: 0.9rem; color: var(--gray); margin-bottom: 1rem;">Generates a unique Game ID for others to join.</p>
                     <button id="create-game-btn" class="btn-full btn-green">
                         <i class="fas fa-magic"></i> Create New Game
                     </button>
                </div>

                <div class="divider">OR</div>

                <div class="card" style="background-color: var(--light-alt);">
                    <h3><i class="fas fa-link"></i> Join Existing Game</h3>
                     <div class="input-group">
                        <div class="input-with-button">
                            <input type="text" id="join-game-id-input" placeholder="Enter Game ID" aria-label="Game ID to join" oninput="this.value = this.value.toUpperCase()">
                            <button class="btn-add" id="join-game-btn"><i class="fas fa-sign-in-alt"></i> Join</button>
                        </div>
                     </div>
                     <div id="join-error" class="error-message"></div>
                </div>
                <button id="back-to-menu-btn" class="btn-full btn-outline" style="margin-top: 1.5rem;"><i class="fas fa-arrow-left"></i> Back to Mode Select</button>
            </div>
            `;
        }

        function renderLoadingGameScreen() {
             return `
                <div class="card">
                    <h2><i class="fas fa-spinner fa-spin"></i> Loading Game...</h2>
                    <p style="text-align: center; color: var(--gray); padding: 2rem 0;">
                        Fetching data for Game ID: ${escapeHtml(currentGameId || 'N/A')}
                    </p>
                </div>
            `;
        }

        function renderPlayerSetup(currentState, mode) {
             // Common player setup UI, potentially with mode-specific elements like Game ID display
             const isOnline = mode === 'online';
             const gameIdHtml = isOnline && currentGameId ? `
                 <div style="margin-bottom: 1.5rem;">
                    <h3 style="font-size: 0.9rem; color: var(--gray); margin-bottom: 0.5rem;">Share this Game ID:</h3>
                    <div class="game-id-display" data-game-id="${escapeHtml(currentGameId)}" title="Click to show QR code">
                        <span style="overflow-wrap: break-word; word-break: break-all; margin: 0 auto;">${escapeHtml(currentGameId)}</span>
                        <i class="fas fa-qrcode" style="margin-left: 8px;"></i>
                    </div>
                    <div style="display: flex; justify-content: center; margin-top: 0.5rem;">
                        <button class="btn-small copy-id-btn" data-game-id="${escapeHtml(currentGameId)}">
                            <i class="far fa-copy"></i> Copy ID
                        </button>
                        <span class="copy-feedback" id="copy-feedback-${escapeHtml(currentGameId)}" style="margin-left: 0.5rem; line-height: 1.8;">Copied!</span>
                    </div>
                 </div>
              ` : '';

              const players = currentState.players || [];

             return `
                <div class="card">
                  <h2><i class="fas fa-users-cog"></i> Player Setup ${isOnline ? '(Online)' : '(Offline)'}</h2>
                  ${gameIdHtml}

                   <div class="input-group">
                     <div class="input-with-button">
                       <input type="text" id="player-name" placeholder="Enter player name" aria-label="Player name">
                       <button class="btn-add" id="add-player-btn"><i class="fas fa-plus"></i> Add Player</button>
                     </div>
                   </div>

                   ${players.length > 0 ? `
                     <div>
                       <h3><i class="fas fa-list-ul"></i> Current Players (${players.length})</h3>
                       <div class="player-list">
                         ${players.map((player, idx) => `
  <div class="player-item">
    <span>${escapeHtml(player)}</span>
    <div style="display: flex; gap: 0.25rem; align-items: center;">
      <button class="btn-move-up" data-player="${escapeHtml(player)}" ${idx === 0 ? 'disabled' : ''} aria-label="Move ${escapeHtml(player)} up" tabindex="0" title="Move up">
        <i class="fas fa-arrow-up"></i>
      </button>
      <button class="btn-move-down" data-player="${escapeHtml(player)}" ${idx === players.length - 1 ? 'disabled' : ''} aria-label="Move ${escapeHtml(player)} down" tabindex="0" title="Move down">
        <i class="fas fa-arrow-down"></i>
      </button>
      <button class="btn-remove" data-player="${escapeHtml(player)}" aria-label="Remove ${escapeHtml(player)}">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
`).join('')}
                       </div>
                     </div>
                   ` : '<p style="text-align: center; color: var(--gray); font-size: 0.9rem; margin: 1.5rem 0;">No players added yet. Add 2 or more to start.</p>'}

                   <button
                     id="start-game-btn"
                     class="btn-full btn-green"
                     ${players.length < 2 ? 'disabled' : ''}
                   >
                     <i class="fas fa-play"></i>
                     ${players.length < 2
                       ? 'Need at least 2 players'
                       : `Start Game (${players.length} Players)`}
                   </button>

                   <div class="button-group" style="margin-top: 1.5rem; justify-content: center;">
                       <button id="back-to-menu-btn" class="btn-outline"><i class="fas fa-arrow-left"></i> Back to Mode Select</button>
                       ${!isOnline ? `<button id="handoff-import-btn" class="btn-small"><i class="fas fa-qrcode"></i> Import from QR</button>` : ''}
                   </div>
                </div>
             `;
        }

        function renderGameplay(currentState, mode) {
            // Common gameplay UI, rendered using the provided state
            const isOnline = mode === 'online';
            let gameplayHtml = '';
            const currentRound = currentState.currentRound || 1;
            const players = currentState.players || [];
            const eliminatedPlayers = currentState.eliminatedPlayers || [];
            const scores = currentState.scores || {};
            const bids = currentState.bids || {};
            const tricks = currentState.tricks || {};
            const bidPhase = currentState.bidPhase === undefined ? true : currentState.bidPhase;
            const dealerName = isOnline ? getDealerName(currentState) : null;

            // --- Round Input / Game Over ---
            if (currentRound <= 14) {
                const bidInfoHtml = bidPhase ? '<div id="bid-info" class="game-info"></div>' : '';
                const tricksInfoHtml = !bidPhase ? '<div id="trick-info" class="game-info"></div>' : '';
                const gameIdHeaderHtml = isOnline && currentGameId ? `
                    <div>
                        <div style="font-size: 0.8rem; margin-bottom: 0.5rem; text-align: center; color: var(--gray);">
                            Game ID: ${escapeHtml(currentGameId)}
                            <button class="btn-text copy-id-btn" data-game-id="${escapeHtml(currentGameId)}" style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.2rem 0.4rem;">
                                <i class="far fa-copy"></i>
                            </button>
                            <span class="copy-feedback" id="copy-feedback-gameplay-${escapeHtml(currentGameId)}" style="margin-left: 0.2rem; font-size: 0.7rem;">Copied!</span>
                        </div>
                    </div>` : '';

                gameplayHtml += `
                <div class="card">
                    ${gameIdHeaderHtml}
                    <div class="flex-between" style="margin-bottom: 0.25rem;">
                    <h2><i class="fas fa-tasks"></i> Round ${currentRound} / 14 ${isOnline ? '(Online)' : '(Offline)'}</h2>
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <span class="game-status">${bidPhase ? 'Bidding Phase' : 'Enter Hands Won'}</span>
                        ${dealerName ? `<span class="game-status" style="background-color: rgba(245,158,11,0.1); color: var(--warning); border: 1px solid rgba(245,158,11,0.3);"><i class="fas fa-star"></i> Dealer: ${escapeHtml(dealerName)}</span>`: ''}
                        <div id="round-elimination-banner" style="display: none; position: static;" class="elimination-banner">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="round-elimination-message">Upcoming elimination</span>
                        </div>
                    </div>

                    ${bidPhase ? bidInfoHtml : tricksInfoHtml}

                    <div class="table-container">
                    <table>
                        <thead>
                        <tr>
                            <th>Player</th>
                            <th>Bid</th>
                            ${!bidPhase ? '<th>Hands Won</th>' : ''}
                            <th>Score</th>
                        </tr>
                        </thead>
                        <tbody>
                        ${players.map(player => {
                            const isDealer = player === dealerName;
                            const bidValue = bids[player] ?? '';
                            const trickValue = tricks[player] ?? '';
                            let playerIndicators = '';
                            if (isDealer) playerIndicators += ' <span class="dealer-indicator">D</span>';

                            return `
                            <tr>
                            <td>${escapeHtml(player)} ${playerIndicators}</td>
                            <td>
                                ${bidPhase
                                ? `<input type="number" min="0" max="${currentRound}" value="${bidValue}"
                                    class="bid-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} bid"
                                    inputmode="numeric" pattern="[0-9]*">`
                                : `<span class="badge badge-blue">${bidValue === '' || bidValue === null ? '?' : bidValue}</span>`}
                            </td>
                            ${!bidPhase
                                ? `<td class="trick-value">
                                    <input type="number" min="0" max="14" value="${trickValue}"
                                    class="trick-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} hands won"
                                    inputmode="numeric" pattern="[0-9]*">
                                </td>`
                                : ''}
                            <td><span class="score-value">${scores[player] || 0}</span></td>
                            </tr>
                        `}).join('')}
                        ${eliminatedPlayers.map(player => `
                                <tr class="eliminated-player">
                                <td>${escapeHtml(player)} <i class="fas fa-user-slash"></i></td>
                                <td>${bids[player] ?? '-'}</td>
                                ${!bidPhase ? `<td>${tricks[player] ?? '-'}</td>` : ''}
                                <td>${scores[player] || 0}</td>
                                </tr>
                            `).join('')}
                         ${players.length === 0 && eliminatedPlayers.length === 0 ? '<tr><td colspan="4" style="text-align:center; color: var(--gray);">No players in game.</td></tr>' : ''}
                        </tbody>
                    </table>
                    </div>

                    ${bidPhase
                    ? `<button id="submit-bids-btn" class="btn-full"><i class="fas fa-check-circle"></i> Confirm Bids</button>`
                    : `<button id="submit-results-btn" class="btn-full btn-green"><i class="fas fa-flag-checkered"></i> Submit Round ${currentRound} Results</button>`
                    }
                </div>
                `;
            } else { // Game Over
                 const winners = getWinners(currentState);
                 const gameIdFooterHtml = isOnline && currentGameId ? `
                    <div style="font-size: 0.8rem; color: var(--gray); text-align: center; margin-top:-0.5rem; margin-bottom: 1rem;">
                        Game ID: ${escapeHtml(currentGameId)}
                    </div>` : '';
                 gameplayHtml += `
                    <div class="card">
                        <h2><i class="fas fa-trophy"></i> Game Over! ${isOnline ? '(Online)' : '(Offline)'}</h2>
                        ${gameIdFooterHtml}
                        ${winners.length > 0
                        ? `<div class="winner-display">
                            <h3>${winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h3>
                            <div class="winner-name">
                                <i class="fas fa-crown"></i> ${winners.map(escapeHtml).join(' & ')}
                            </div>
                            <p>${scores[winners[0]] || 0} points</p>
                            </div>`
                        : '<p style="text-align:center; color: var(--gray);">Could not determine winner.</p>'}

                        <button id="reset-game-btn" class="btn-full btn-red">
                           <i class="fas fa-power-off"></i> Start New Game ${isOnline ? '(Resets Room)' : ''}
                        </button>
                         <button id="back-to-menu-btn" class="btn-full btn-outline" style="margin-top: 0.75rem;">
                            <i class="fas fa-arrow-left"></i> Back to Mode Select
                        </button>
                    </div>
                 `;
            }

            // --- Scoreboard (Common for both modes) ---
             const allPlayersForScoreboard = [...new Set([...(currentState.players || []), ...(currentState.eliminatedPlayers || [])])];
             const sortedPlayers = getSortedPlayers(scores, allPlayersForScoreboard);

            gameplayHtml += `
                <div class="card">
                <h2><i class="fas fa-clipboard-list"></i> Scoreboard</h2>
                <div class="table-container">
                    <table>
                    <thead><tr><th>Rank</th><th>Player</th><th>Score</th></tr></thead>
                    <tbody>
                        ${sortedPlayers.map((player, index) => {
                            const rank = index + 1;
                            const isEliminated = eliminatedPlayers.includes(player);
                            const isWinner = currentRound > 14 && getWinners(currentState).includes(player);
                            let medal = '';
                            if (isWinner && rank === 1) medal = '<i class="fas fa-medal" style="color: #d4af37;"></i>';
                            else if (currentRound > 14 && rank === 2) medal = '<i class="fas fa-medal" style="color: #c0c0c0;"></i>';
                            else if (currentRound > 14 && rank === 3) medal = '<i class="fas fa-medal" style="color: #cd7f32;"></i>';
                            return `
                        <tr class="${isWinner ? 'winner-row' : ''} ${isEliminated ? 'eliminated-player' : ''}">
                            <td>${rank} ${medal}</td>
                            <td>${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</td>
                            <td>${scores[player] || 0}</td>
                        </tr>`;
                        }).join('')}
                         ${sortedPlayers.length === 0 ? '<tr><td colspan="3" style="text-align:center; color: var(--gray);">No players on scoreboard yet.</td></tr>' : ''}
                    </tbody>
                    </table>
                </div>
                </div>

                ${currentRound <= 14 ? `
                    <div class="flex-between">
                    <div class="button-group">
                         ${!isOnline ? `<button id="undo-round-btn" class="btn-outline"><i class="fas fa-undo-alt"></i> Undo Round</button>` : ''}
                         <button id="leave-game-btn" class="btn-leave-game"><i class="fas fa-sign-out-alt"></i> Leave</button>
                         <button id="reset-game-btn" class="btn-red"><i class="fas fa-power-off"></i> Reset Game</button>
                         ${isOnline && currentGameId ? `<button id="show-qr-btn" class="btn-small"><i class="fas fa-qrcode"></i></button>` : ''}
                         ${!isOnline ? `<button id="handoff-qr-btn" class="btn-small"><i class="fas fa-qrcode"></i> Hand-off via QR</button>` : ''}
                    </div>
                    <p>Round ${currentRound} / 14</p>
                    </div>
                    ` : ''}
            `;

            return gameplayHtml;
        }

        function renderCompletedGames() {
            // Always uses local history
            completedGamesList.innerHTML = localHistory.length > 0
                ? localHistory.slice().reverse().map((game, index) => {
                    const originalIndex = localHistory.length - 1 - index;
                    game.eliminatedPlayers = game.eliminatedPlayers || [];
                    const allParticipants = [...new Set([...(game.players || []), ...game.eliminatedPlayers])];
                    const modeBadge = game.mode === 'online' ? '<span class="badge badge-blue" style="font-size:0.7rem; margin-left: 5px;">Online</span>' : '<span class="badge" style="font-size:0.7rem; margin-left: 5px; background: rgba(107, 114, 128, 0.1); color: var(--gray);">Offline</span>';
                    const elimCount = game.eliminatedPlayers.length ? `<span style="color: var(--danger)"><i class="fas fa-user-slash"></i> ${game.eliminatedPlayers.length}</span>` : '';

                    return `<div class="completed-game-item" data-game-index="${originalIndex}">
                                <div><i class="fas fa-calendar-alt"></i> ${new Date(game.date).toLocaleDateString()} ${new Date(game.date).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })} ${modeBadge}</div>
                                <div class="game-winner"><i class="fas fa-trophy"></i> ${game.winners.map(escapeHtml).join(' & ')}</div>
                                <div class="game-score"><i class="fas fa-star"></i> ${game.score} points</div>
                                <div style="font-size: 0.8rem;">
                                <i class="fas fa-users"></i> ${allParticipants.length} Players ${elimCount ? `(${elimCount} Eliminated)` : ''}
                                ${game.gameId ? `<span style="font-family:monospace; font-size:0.7rem; color:var(--gray); margin-left:auto;">ID: ${escapeHtml(game.gameId.substring(0, 6))}...</span>` : ''}
                                </div>
                            </div>`;
                }).join('')
                : '<div class="no-games"><i class="fas fa-folder-open"></i> No completed games yet</div>';
        }

        // --- Offline Mode Logic ---

        function getDefaultOfflineState() {
            return {
                players: [],
                gameStarted: false,
                currentRound: 1,
                bids: {},
                tricks: {},
                scores: {},
                bidPhase: true,
                roundHistory: [], // Specific to offline for undo
                eliminatedPlayers: []
            };
        }

        function loadOfflineState() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (savedState) {
                try {
                    offlineState = JSON.parse(savedState);
                    // Ensure all default keys exist for compatibility
                     offlineState = { ...getDefaultOfflineState(), ...offlineState };
                    console.log('Offline game state loaded.');
                } catch (err) {
                    console.error('Error loading offline game state:', err);
                    offlineState = getDefaultOfflineState();
                    localStorage.removeItem(LOCAL_STORAGE_OFFLINE_KEY);
                }
            } else {
                offlineState = getDefaultOfflineState();
                console.log('No saved offline game state found, using default.');
            }
        }

        function saveOfflineState() {
            try {
                localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(offlineState));
            } catch (err) {
                console.error('Error saving offline game state:', err);
            }
        }

        function addPlayerOffline() {
            const playerNameInput = document.getElementById('player-name');
            if (!playerNameInput) return;
            let playerName = playerNameInput.value.trim();
            if (playerName.length > 0) playerName = playerName.charAt(0).toUpperCase() + playerName.slice(1);

            if (playerName && !offlineState.players.includes(playerName)) {
                if (offlineState.players.length >= MAX_PLAYERS) { alert(`Maximum of ${MAX_PLAYERS} players allowed.`); return; }
                offlineState.players.push(playerName);
                offlineState.scores[playerName] = 0; // Initialize score
                playerNameInput.value = '';
                saveOfflineState();
                renderApp();
            } else if (offlineState.players.includes(playerName)) {
                alert(`Player "${escapeHtml(playerName)}" already exists!`);
                playerNameInput.select();
            } else {
                playerNameInput.focus();
            }
        }

        function removePlayerOffline(playerToRemove) {
            offlineState.players = offlineState.players.filter(p => p !== playerToRemove);
            delete offlineState.scores[playerToRemove];
            delete offlineState.bids[playerToRemove];
            delete offlineState.tricks[playerToRemove];
            // Clear from history if needed? Maybe not for offline.
            saveOfflineState();
            renderApp();
        }

        function startGameOffline() {
            if (offlineState.players.length < 2) { alert("Need at least 2 players."); return; }
            offlineState.gameStarted = true;
            offlineState.currentRound = 1;
            offlineState.bidPhase = true;
            offlineState.bids = {};
            offlineState.tricks = {};
            offlineState.eliminatedPlayers = [];
            offlineState.roundHistory = []; // Reset history
            offlineState.players.forEach(p => { offlineState.scores[p] = 0; });
            saveOfflineState();
            renderApp();
            checkUpcomingElimination(offlineState);
        }

         function handleBidChangeOffline(player, value) {
            const maxBid = offlineState.currentRound;
            const bidValue = value === '' ? undefined : Math.min(Math.max(0, parseInt(value) || 0), maxBid);
            offlineState.bids[player] = bidValue;
            saveOfflineState();
            updateValidationAndButtons(); // Faster UI feedback without full re-render
         }

         function handleTricksChangeOffline(player, value) {
            const tricksValue = value === '' ? undefined : Math.min(Math.max(0, parseInt(value) || 0), 14);
            offlineState.tricks[player] = tricksValue;
            saveOfflineState();
            updateValidationAndButtons();
         }

         function submitBidsOffline() {
             if (!allBidsEntered(offlineState)) {
                 alert("Please ensure all players have entered a valid bid, and the total bids do not equal the current round number."); return;
             }
             offlineState.bidPhase = false;
             offlineState.tricks = {}; // Clear tricks for this phase
             offlineState.players.forEach(p => offlineState.tricks[p] = undefined); // Explicitly undefined
             saveOfflineState();
             renderApp();
         }

         function submitRoundResultsOffline() {
            if (!allTricksEntered(offlineState) || !validateTricksTotal(offlineState)) {
                alert("Please enter hands won for all players, and ensure the total equals the current round number."); return;
            }

            // Save current state for undo
            offlineState.roundHistory.push(JSON.parse(JSON.stringify({
                currentRound: offlineState.currentRound,
                bids: offlineState.bids,
                tricks: offlineState.tricks,
                scores: offlineState.scores,
                bidPhase: offlineState.bidPhase,
                eliminatedPlayers: [...offlineState.eliminatedPlayers]
             })));

             // Calculate scores
             let newEliminatedPlayer = null;
             offlineState.players.forEach(player => {
                 const bid = offlineState.bids[player];
                 const tricks = offlineState.tricks[player];
                 if (typeof bid === 'number' && typeof tricks === 'number') {
                     let roundScore = (bid === tricks) ? (bid === 0 ? 10 : tricks + (10 * bid)) : tricks;
                     offlineState.scores[player] = (offlineState.scores[player] || 0) + roundScore;
                 }
             });

             if (offlineState.currentRound < 14) {
                 offlineState.currentRound++;
                 offlineState.bidPhase = true;
                 offlineState.bids = {}; // Reset bids/tricks for next round
                 offlineState.tricks = {};
                 offlineState.players.forEach(p => { offlineState.bids[p] = undefined; offlineState.tricks[p] = undefined; });

                 newEliminatedPlayer = checkElimination(offlineState); // Check for elimination
                 if (newEliminatedPlayer) {
                     offlineState.eliminatedPlayers.push(newEliminatedPlayer);
                     offlineState.players = offlineState.players.filter(p => p !== newEliminatedPlayer);
                 }
                 checkUpcomingElimination(offlineState);

             } else {
                 offlineState.currentRound = 15; // Game over
                 saveCompletedGameToLocal(offlineState, 'offline');
                 localStorage.removeItem(LOCAL_STORAGE_OFFLINE_KEY); // Clear current game state after saving history
             }

             saveOfflineState(); // Save potentially modified state (elimination, next round)
             renderApp();
         }

        function resetGameOffline() {
            if (confirm("Are you sure you want to start a new offline game? This will clear the current offline game progress.")) {
                offlineState = getDefaultOfflineState();
                saveOfflineState();
                previousHtml = ''; // Force re-render
                renderApp();
                hideEliminationBanner();
            }
        }

        function undoRoundOffline() {
             if (offlineState.roundHistory && offlineState.roundHistory.length > 0) {
                if (confirm("Are you sure you want to undo the last round?")) {
                    const prevState = offlineState.roundHistory.pop();

                    // Restore previous state values
                    offlineState.currentRound = prevState.currentRound;
                    offlineState.bids = prevState.bids;
                    offlineState.scores = prevState.scores;
                    offlineState.eliminatedPlayers = prevState.eliminatedPlayers; // Restore eliminated list

                    // Restore active players list based on who had scores in the previous state
                    // and remove players who were only eliminated *after* that round
                    const previousActivePlayers = Object.keys(prevState.scores).filter(p => !prevState.eliminatedPlayers.includes(p));
                    offlineState.players = previousActivePlayers;


                    offlineState.bidPhase = true; // Always go back to bidding phase
                    offlineState.tricks = {}; // Clear tricks for the restored round
                     offlineState.players.forEach(p => offlineState.tricks[p] = undefined);

                    saveOfflineState();
                    renderApp();
                    checkUpcomingElimination(offlineState); // Recheck eliminations
                }
             } else {
                 alert("No rounds to undo.");
             }
        }

        // --- Online Mode Logic ---

        // Add function to generate short alphanumeric game IDs
        function generateRandomId(length = 6) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < length; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        async function createOnlineGame() {
            if (!firebaseConnected) { alert("Not connected to Firebase."); return; }
            setLoading(true, "Creating game...");

            const initialGameState = {
                players: [], gameStarted: false, currentRound: 1, dealerIndex: 0,
                bids: {}, tricks: {}, scores: {}, bidPhase: true, eliminatedPlayers: [],
                createdAt: firebase.database.ServerValue.TIMESTAMP
            };

            // Generate a unique short game ID
            const db = firebase.database();
            let newGameId, snapshot;
            do {
                newGameId = generateRandomId(6);
                snapshot = await db.ref(`games/${newGameId}`).once('value');
            } while (snapshot.exists());
            const newGameRef = db.ref(`games/${newGameId}`);

            newGameRef.set(initialGameState)
                .then(() => {
                    console.log(`Online game created with ID: ${newGameId}`);
                    currentGameId = newGameId;
                    currentMode = 'online-game'; // Switch mode
                    attachGameListener(currentGameId); // Listener will handle render and hide loading
                })
                .catch(err => {
                    console.error("Failed to create online game:", err);
                    alert("Error creating game. Please try again.");
                    setLoading(false);
                });
        }

        function joinOnlineGame() {
            const joinIdInput = document.getElementById('join-game-id-input');
            const joinErrorEl = document.getElementById('join-error');
            let gameId = joinIdInput ? joinIdInput.value.trim() : '';
            
            // Check if there's a game ID in the URL (from QR code scanning)
            if (!gameId) {
                const urlParams = new URLSearchParams(window.location.search);
                const qrGameId = urlParams.get('game');
                if (qrGameId) {
                    gameId = qrGameId;
                    // Update the input field if it exists
                    if (joinIdInput) {
                        joinIdInput.value = gameId;
                    }
                    // Clean the URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
            
            if (!gameId) {
                if (joinErrorEl) joinErrorEl.textContent = 'Please enter a Game ID';
                return;
            }

            if (!firebaseInitialized) {
                initializeFirebaseIfNeeded();
                // If Firebase fails to initialize, the firebaseInitialized flag remains false
                if (!firebaseInitialized) {
                    if (joinErrorEl) joinErrorEl.textContent = 'Failed to initialize online services';
                    return;
                }
            }

            setLoading(true, 'Joining game...');
            const database = firebase.database();

            // Check if the game exists
            database.ref(`/games/${gameId}`).once('value').then((snapshot) => {
                if (snapshot.exists()) {
                    currentGameId = gameId;
                    currentMode = 'online-game'; // Set to game mode immediately
                    onlineState = {}; // Reset local state
                    menuBackButton.style.display = 'inline-block';
                    attachGameListener(gameId);
                } else {
                    setLoading(false);
                    if (joinErrorEl) joinErrorEl.textContent = 'Game not found. Check the Game ID and try again.';
                }
            }).catch(err => {
                console.error('Error checking game existence:', err);
                setLoading(false);
                if (joinErrorEl) joinErrorEl.textContent = err.message || 'Error checking game. Please try again.';
            });
        }

        function leaveOnlineGame(renderEntry = true) {
             console.log("Leaving online game:", currentGameId);
             detachGameListener();
             currentGameId = null;
             onlineState = {}; // Clear cache
             previousHtml = ''; // Force re-render if needed
             if (renderEntry) {
                 currentMode = 'online-entry'; // Go back to online create/join
                 renderApp();
             }
        }

        function attachGameListener(gameId) {
            if (gameListenerHandle) detachGameListener();
            if (!gameId) { console.error("Attach listener: No game ID."); return; }

            console.log(`Attaching listener to game: ${gameId}`);
            gameRef = firebase.database().ref('games').child(gameId);
            setLoading(true, 'Loading game data...');

            gameListenerHandle = gameRef.on('value', (snapshot) => {
                if (!currentGameId || gameId !== currentGameId) {
                    console.log(`Listener ignored for ${gameId}, current is ${currentGameId}.`);
                    return; // Stale listener after leaving
                }
                setLoading(false);
                const firebaseState = snapshot.val();
                if (firebaseState) {
                     // Overwrite local cache with Firebase state
                     onlineState = {
                         players: firebaseState.players || [],
                         gameStarted: firebaseState.gameStarted || false,
                         currentRound: firebaseState.currentRound || 1,
                         dealerIndex: firebaseState.dealerIndex === undefined ? 0 : firebaseState.dealerIndex,
                         bids: firebaseState.bids || {},
                         tricks: firebaseState.tricks || {},
                         scores: firebaseState.scores || {},
                         bidPhase: firebaseState.bidPhase === undefined ? true : firebaseState.bidPhase,
                         eliminatedPlayers: firebaseState.eliminatedPlayers || [],
                         createdAt: firebaseState.createdAt // Keep track if needed
                     };
                     
                     // Check for completed game data and save it to local history for this user
                     if (firebaseState.completedGameData && firebaseState.completedGameData.completed) {
                         const localGame = localHistory.find(g => g.gameId === currentGameId && g.mode === 'online');
                         // Only save if this game hasn't been saved locally before
                         if (!localGame) {
                             const completedGame = {
                                 mode: 'online',
                                 gameId: currentGameId,
                                 date: firebaseState.completedGameData.date,
                                 winners: firebaseState.completedGameData.winners,
                                 score: firebaseState.completedGameData.score,
                                 players: firebaseState.completedGameData.players,
                                 finalScores: firebaseState.completedGameData.finalScores,
                                 eliminatedPlayers: firebaseState.completedGameData.eliminatedPlayers
                             };
                             
                             localHistory = JSON.parse(localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY)) || [];
                             localHistory.push(completedGame);
                             localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(localHistory));
                             renderCompletedGames();
                             console.log(`Saved completed online game ${currentGameId} to local history.`);
                         }
                     }
                     
                     console.log(`Firebase data received for game ${currentGameId}`);
                     currentMode = 'online-game'; // Ensure mode is correct
                     
                     // Add a small buffer delay before rendering to allow for closely timed Firebase updates
                     // This prevents multiple renders when Firebase sends multiple updates in quick succession
                     setTimeout(() => {
                         throttledRender();
                     }, FIREBASE_UPDATE_BUFFER);
                } else {
                     console.error("Firebase returned null value for game");
                     alert("Game not found. It may have been deleted.");
                     leaveOnlineGame(true);
                }
            }, (err) => {
                console.error("Firebase listener error:", err);
                setLoading(false);
                alert(`Error receiving game updates: ${err.message}`);
            });
        }

        function detachGameListener() {
            if (gameRef && gameListenerHandle) {
                console.log(`Detaching listener from game: ${currentGameId}`);
                gameRef.off('value', gameListenerHandle);
            }
            gameListenerHandle = null;
            gameRef = null;
        }

        function addPlayerOnline() {
             if (!firebaseConnected || !gameRef || !onlineState) return;
             if (onlineState.gameStarted) { alert("Cannot add players after game start."); return; }

             const playerNameInput = document.getElementById('player-name');
             if (!playerNameInput) return;
             let playerName = playerNameInput.value.trim();
             if (playerName.length > 0) playerName = playerName.charAt(0).toUpperCase() + playerName.slice(1);

             const currentPlayers = onlineState.players || [];
             if (playerName && !currentPlayers.includes(playerName)) {
                if (currentPlayers.length >= MAX_PLAYERS) { alert(`Maximum of ${MAX_PLAYERS} players.`); return; }
                const updatedPlayers = [...currentPlayers, playerName];
                const updates = {};
                updates['/players'] = updatedPlayers;
                updates[`/scores/${playerName}`] = 0;
                updates[`/bids/${playerName}`] = null; // Use null for Firebase empty state
                updates[`/tricks/${playerName}`] = null;

                gameRef.update(updates)
                    .then(() => { playerNameInput.value = ''; console.log(`Player ${playerName} added online.`); })
                    .catch(err => { console.error("Online add player failed:", err); alert("Error adding player."); });
             } else if (currentPlayers.includes(playerName)) {
                 alert(`Player "${escapeHtml(playerName)}" already exists!`);
                 playerNameInput.select();
             } else {
                 playerNameInput.focus();
             }
        }

        function removePlayerOnline(playerToRemove) {
             if (!firebaseConnected || !gameRef || !onlineState) return;
             if (onlineState.gameStarted) { alert("Cannot remove players after game start."); return; }

             const currentPlayers = onlineState.players || [];
             const updatedPlayers = currentPlayers.filter(p => p !== playerToRemove);
             const updates = {};
             updates['/players'] = updatedPlayers;
             updates[`/scores/${playerToRemove}`] = null; // Remove data
             updates[`/bids/${playerToRemove}`] = null;
             updates[`/tricks/${playerToRemove}`] = null;

             // Adjust dealer index carefully
             let newDealerIndex = onlineState.dealerIndex;
             const removedPlayerIndex = currentPlayers.indexOf(playerToRemove);
             if (removedPlayerIndex !== -1 && removedPlayerIndex < newDealerIndex) newDealerIndex--;
             newDealerIndex = updatedPlayers.length > 0 ? Math.max(0, newDealerIndex) % updatedPlayers.length : 0;
             updates['/dealerIndex'] = newDealerIndex;

             gameRef.update(updates)
                .then(() => console.log(`Player ${playerToRemove} removed online.`))
                .catch(err => { console.error("Online remove player failed:", err); alert("Error removing player."); });
        }

        function startGameOnline() {
            if (!firebaseConnected || !gameRef || !onlineState) return;
            if ((onlineState.players || []).length < 2) { alert("Need at least 2 players."); return; }

            const initialScores = {};
            const initialBids = {};
            const initialTricks = {};
            (onlineState.players || []).forEach(p => {
                initialScores[p] = 0; initialBids[p] = null; initialTricks[p] = null;
            });

            const updates = {
                gameStarted: true, currentRound: 1, dealerIndex: 0, bidPhase: true,
                scores: initialScores, bids: initialBids, tricks: initialTricks, eliminatedPlayers: [],
            };

            gameRef.update(updates)
                .then(() => console.log(`Online game ${currentGameId} started.`))
                .catch(err => { console.error("Online start game failed:", err); alert("Error starting game."); });
        }

        function submitBidsOnline() {
             if (!firebaseConnected || !gameRef || !onlineState) return;
             if (!allBidsEntered(onlineState)) { alert("Invalid bids. Check totals and ensure all players have bid."); return; }

             const updates = {};
             updates['/bidPhase'] = false;
             // Remove this line: updates['/tricks'] = {}; // Clear tricks node
             (onlineState.players || []).forEach(p => updates[`/tricks/${p}`] = null); // Set each player's trick to null

             gameRef.update(updates)
                .then(() => console.log("Online bids submitted."))
                .catch(err => { console.error("Online submit bids failed:", err); alert("Error submitting bids."); });
        }

        function submitRoundResultsOnline() {
            if (!firebaseConnected || !gameRef || !onlineState) return;
            if (!allTricksEntered(onlineState)) { alert("All tricks must be entered."); return; }

            const activePlayers = [...(onlineState.players || [])];
            if (activePlayers.length === 0) return;

            const currentScores = { ...onlineState.scores };
            const round = onlineState.currentRound;

            // Calculate scores for this round
            activePlayers.forEach(playerName => {
                const playerBid = onlineState.bids[playerName] || 0;
                const playerTricks = onlineState.tricks[playerName] || 0;
                let roundScore = 0;

                if (playerBid === playerTricks) {
                    roundScore = (playerBid === 0) ? 10 : playerTricks + (10 * playerBid);
                } else {
                    roundScore = playerTricks;
                }

                currentScores[playerName] = (currentScores[playerName] || 0) + roundScore;
            });

            // Prepare for next round
            let nextRound = round;
            let nextDealerIndex = onlineState.dealerIndex || 0;
            let nextActivePlayers = [...activePlayers];
            let nextEliminatedPlayers = [...(onlineState.eliminatedPlayers || [])];
            let newEliminatedPlayer = null;
            let gameIsOver = false;

            // Prepare updates for Firebase
            const updates = {};

            if (onlineState.currentRound < 14) {
                nextRound++;
                nextDealerIndex = activePlayers.length > 0 ? (onlineState.dealerIndex + 1) % activePlayers.length : 0;

                newEliminatedPlayer = checkElimination(currentScores, nextActivePlayers, nextRound); // Pass scores, players and next round number
                if (newEliminatedPlayer) {
                    // Alert locally - maybe improve this UX later
                    alert(`Player "${escapeHtml(newEliminatedPlayer)}" eliminated! (Lowest score: ${currentScores[newEliminatedPlayer]})`);

                    nextEliminatedPlayers.push(newEliminatedPlayer);
                    nextActivePlayers = nextActivePlayers.filter(p => p !== newEliminatedPlayer);

                    // Adjust dealer index for the NEW player list
                    const originalEliminatedIndex = activePlayers.indexOf(newEliminatedPlayer);
                    if (originalEliminatedIndex !== -1 && originalEliminatedIndex < nextDealerIndex) {
                        nextDealerIndex--;
                    }
                    nextDealerIndex = nextActivePlayers.length > 0 ? Math.max(0, nextDealerIndex) % nextActivePlayers.length : 0;
                }
            } else {
                nextRound = 15; // Game over
                gameIsOver = true;
                // Prepare final state to save to local history
                const finalStateForHistory = {
                    ...onlineState, // Include current bids/tricks etc.
                    scores: currentScores, // Use the just calculated final scores
                    players: nextActivePlayers, // Final active players
                    eliminatedPlayers: nextEliminatedPlayers // Final eliminated players
                };
                saveCompletedGameToLocal(finalStateForHistory, 'online');
                
                // For online games that are over, store completed game information in Firebase
                // so that all players who were in the game can access it
                const winners = getWinners(finalStateForHistory);
                const completedGameData = {
                    date: new Date().toISOString(),
                    winners: winners,
                    score: winners.length > 0 ? (finalStateForHistory.scores[winners[0]] || 0) : 0,
                    players: [...(finalStateForHistory.players || [])],
                    finalScores: { ...(finalStateForHistory.scores || {}) },
                    eliminatedPlayers: [...(finalStateForHistory.eliminatedPlayers || [])],
                    completed: true
                };
                updates['/completedGameData'] = completedGameData;
            }
            
            updates['/scores'] = currentScores;
            updates['/currentRound'] = nextRound;
            updates['/bidPhase'] = true;
            updates['/dealerIndex'] = nextDealerIndex;
            updates['/players'] = nextActivePlayers;
            updates['/eliminatedPlayers'] = nextEliminatedPlayers;

            // Reset bids and tricks for NEXT round (only for remaining active players)
            const resetBids = {};
            const resetTricks = {};
            nextActivePlayers.forEach(p => { resetBids[p] = null; resetTricks[p] = null; });
            // Preserve bids/tricks of previously eliminated players
            (onlineState.eliminatedPlayers || []).forEach(p => {
                if (onlineState.bids[p] !== undefined) resetBids[p] = onlineState.bids[p];
                if (onlineState.tricks[p] !== undefined) resetTricks[p] = onlineState.tricks[p];
            });
            // Preserve bids/tricks of newly eliminated player for history, but REMOVE from next round logic
            if (newEliminatedPlayer) {
                // Remove from next round's bids/tricks
                delete resetBids[newEliminatedPlayer];
                delete resetTricks[newEliminatedPlayer];
            }

            updates['/bids'] = resetBids;
            updates['/tricks'] = resetTricks;

            gameRef.update(updates)
                .then(() => {
                    console.log(`Online round ${onlineState.currentRound} results submitted.`);
                    if (gameIsOver) console.log(`Online game ${currentGameId} Over!`);
                    // Listener will handle re-render and checkUpcomingElimination
                })
                .catch(err => {
                    console.error("Online submit results failed:", err);
                    alert("Error submitting results.");
                });
        }

        function resetGameOnline() {
            if (!firebaseConnected || !gameRef) return;
            if (confirm("RESET ONLINE GAME ROOM?\n\nThis will clear scores and restart the game for EVERYONE currently in this room ID. This cannot be undone.")) {
                // Save the current game state to local history first with reset notation
                if (onlineState && Object.keys(onlineState).length > 0) {
                    const finalStateForHistory = {
                        ...onlineState,
                        wasReset: true // Add flag to indicate this game was reset
                    };
                    saveCompletedGameToLocal(finalStateForHistory, 'online');
                }
                
                // Delete the game from Firebase completely
                gameRef.remove()
                    .then(() => { 
                        console.log(`Online game ${currentGameId} deleted from Firebase.`); 
                        hideEliminationBanner();
                        
                        // Create a new game with the same ID
                        const initialGameState = {
                            players: [], gameStarted: false, currentRound: 1, dealerIndex: 0,
                            bids: {}, tricks: {}, scores: {}, bidPhase: true, eliminatedPlayers: [],
                            createdAt: firebase.database.ServerValue.TIMESTAMP
                        };
                        
                        // Re-create the game with the same ID
                        firebase.database().ref(`games/${currentGameId}`).set(initialGameState)
                            .then(() => {
                                console.log(`Online game ${currentGameId} reset with new state.`);
                            })
                            .catch(err => { 
                                console.error("Failed to re-create game after deletion:", err); 
                                alert("Error resetting game."); 
                                leaveOnlineGame(true); // Go back to entry screen on failure
                            });
                    })
                    .catch(err => { 
                        console.error("Online reset/delete failed:", err); 
                        alert("Error resetting game."); 
                    });
            }
        }

        // --- Shared Helper & Validation Functions ---

        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                 .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;").replace(/'/g, "&#39;");
        }

        function applyTheme(theme) {
            const newTheme = (theme === 'dark') ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            darkModeToggle.checked = newTheme === 'dark';
            localStorage.setItem(LOCAL_STORAGE_THEME_KEY, newTheme);
            console.log("Theme applied:", newTheme);
        }

        function setLoading(isLoading, message = 'Loading...') {
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingMessage = document.getElementById('loading-message');
            
            if (!loadingOverlay) return;
            
            if (isLoading) {
                loadingOverlay.classList.add('active');
                if (loadingMessage) {
                    loadingMessage.innerHTML = message;
                }
            } else {
                loadingOverlay.classList.remove('active');
            }
        }

        function getDealerName(currentState) { // Online only helper
            const players = currentState.players || [];
            if (!currentState.gameStarted || players.length === 0) return null;
            const index = currentState.dealerIndex ?? 0;
            const adjustedIndex = Math.max(0, Math.min(index, players.length - 1));
            return players[adjustedIndex];
        }

        function calculateTotalBids(bids, players) {
            return (players || []).reduce((sum, p) => {
                const bid = bids && bids[p];
                return sum + (bid === null || bid === undefined ? 0 : Number(bid) || 0);
            }, 0);
        }

        function calculateTotalTricks(tricks, players) {
            return (players || []).reduce((sum, p) => {
                const trick = tricks && tricks[p];
                return sum + (trick === null || trick === undefined ? 0 : Number(trick) || 0);
            }, 0);
        }

        function calculatePotentialBidTotal(playerMakingBid, bidValue, currentState) { // Online helper
            const potentialBids = { ...(currentState.bids || {}) };
            potentialBids[playerMakingBid] = bidValue ?? 0; // Treat null/undefined as 0
            return calculateTotalBids(potentialBids, currentState.players);
        }

        function allPlayersHaveBid(currentState) {
            const players = currentState.players || [];
            if (players.length === 0) return false;
            return players.every(p => currentState.bids && currentState.bids[p] !== undefined && currentState.bids[p] !== null);
        }

        function allPlayersHaveTricks(currentState) {
             const players = currentState.players || [];
             if (players.length === 0) return false;
             return players.every(p => currentState.tricks && currentState.tricks[p] !== undefined && currentState.tricks[p] !== null);
        }

        function allBidsEntered(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || !currentState.bidPhase || players.length === 0) return false;
            if (!allPlayersHaveBid(currentState)) return false;
            const totalBids = calculateTotalBids(currentState.bids, players);
            return totalBids !== currentState.currentRound;
        }

        function allTricksEntered(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || currentState.bidPhase || players.length === 0) return false;
            return allPlayersHaveTricks(currentState);
        }

        function validateTricksTotal(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || currentState.bidPhase || players.length === 0) return false;
            const totalTricks = calculateTotalTricks(currentState.tricks, players);
            return totalTricks === currentState.currentRound;
        }

        function getWinners(currentState) {
             if (!currentState || !currentState.gameStarted || currentState.currentRound <= 14) return [];
             const scores = currentState.scores || {};
             if (Object.keys(scores).length === 0) return [];

             const finalPlayers = [...new Set([...(currentState.players || []), ...(currentState.eliminatedPlayers || [])])];
             if (finalPlayers.length === 0) return [];

             let highestScore = -Infinity;
             finalPlayers.forEach(player => { highestScore = Math.max(highestScore, scores[player] || 0); });
             if (highestScore === -Infinity) return [];

             return finalPlayers.filter(player => (scores[player] || 0) === highestScore);
        }

        function getSortedPlayers(scores, playerList) {
             if (!playerList || playerList.length === 0) return [];
             const scoresObj = scores || {};
             return [...playerList]
                .map(player => ({ name: player, score: scoresObj[player] || 0 }))
                .sort((a, b) => b.score - a.score)
                .map(p => p.name);
        }

        function checkElimination(currentState, activePlayers, nextRound) {
             // Handle both types of calls:
             // 1. Single param (offline mode): currentState contains all data
             // 2. Three params (online mode): currentState=scores object, activePlayers=players array, nextRound=round number
             
             let players, scores, currentRound;
             
             if (arguments.length === 1) {
                 // Offline mode
                 players = currentState.players || [];
                 scores = currentState.scores || {};
                 currentRound = currentState.currentRound || 1;
             } else {
                 // Online mode
                 scores = currentState || {};
                 players = activePlayers || [];
                 currentRound = nextRound || 1;
             }

             if (players.length * currentRound > ELIMINATION_THRESHOLD && players.length > 1) {
                 let lowestScore = Infinity;
                 players.forEach(p => { lowestScore = Math.min(lowestScore, scores[p] || 0); });

                 const lowestPlayers = players.filter(p => (scores[p] || 0) === lowestScore);
                 if (lowestPlayers.length > 0) {
                    // Eliminate the first player found with the lowest score
                     const playerToEliminate = lowestPlayers[0];
                     console.log(`Eliminating player: ${playerToEliminate} (Score: ${lowestScore}) in round ${currentRound}`);
                     // In offline mode, this function returns the player name to be handled by the caller
                     // In online mode, the alert happens here for simplicity, but the caller handles state update
                     if (currentMode === 'offline') {
                         alert(`Player "${escapeHtml(playerToEliminate)}" eliminated! (Lowest score: ${lowestScore})`);
                     }
                     return playerToEliminate;
                 }
             }
             return null; // No elimination
        }

        function checkUpcomingElimination(currentState) {
            if (!currentState || !currentState.gameStarted || currentState.currentRound > 14 || !currentState.players || currentState.players.length < 2) {
                hideEliminationBanner(); 
                return;
            }
            
            // Check if elimination will happen in any future round
            let eliminationRound = null;
            for (let futureRound = currentState.currentRound; futureRound <= 14; futureRound++) {
                if (currentState.players.length * futureRound > ELIMINATION_THRESHOLD) {
                    eliminationRound = futureRound;
                    break;
                }
            }
            
            // Only update DOM if needed
            if (eliminationRound) {
                showEliminationBanner(eliminationRound);
            } else {
                hideEliminationBanner();
            }
        }

        function showEliminationBanner(round) {
            const roundMessage = document.getElementById('round-elimination-message');
            const roundBanner = document.getElementById('round-elimination-banner');
            if (roundMessage && roundBanner) {
                roundMessage.textContent = `Elimination at Round ${round}`;
                // Always keep the element in DOM but control visibility with opacity
                if (roundBanner.style.display === 'none') {
                    roundBanner.style.display = 'flex';
                }
            }
            // Keep fixed banner hidden
            const origBanner = document.getElementById('elimination-banner');
            if (origBanner) origBanner.style.display = 'none';
        }
        
        function hideEliminationBanner() {
            const origBanner = document.getElementById('elimination-banner');
            if (origBanner) origBanner.style.display = 'none';
            
            const roundBanner = document.getElementById('round-elimination-banner');
            if (roundBanner) roundBanner.style.display = 'none';
        }

        function copyGameIdToClipboard(gameId, displayElement) {
             if (!navigator.clipboard) { alert("Clipboard not available."); return; }
             navigator.clipboard.writeText(gameId).then(() => {
                 const feedbackEl = displayElement.querySelector('.copy-feedback');
                 if (feedbackEl) {
                     feedbackEl.classList.add('visible');
                     setTimeout(() => feedbackEl.classList.remove('visible'), 1500);
                 }
             }).catch(err => { console.error('Failed to copy:', err); alert('Copy failed.'); });
        }

        function showQRCode(gameId) {
            const qrCodeModal = document.getElementById('qr-code-modal');
            const qrCodeContainer = document.getElementById('qr-code-container');
            const qrCodeClose = document.getElementById('qr-code-close');
            
            // Clear previous QR code
            qrCodeContainer.innerHTML = '';
            
            // Generate a QR code with just the game ID as plain text
            // This will allow the user to easily copy it after scanning
            const qrData = gameId;
            
            try {
                // Generate QR code with qrcodejs
                new QRCode(qrCodeContainer, {
                    text: qrData,
                    width: 250,
                    height: 250,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Add game ID display and copy button below QR code
                const infoContainer = document.createElement('div');
                infoContainer.style.marginTop = '1rem';
                infoContainer.style.textAlign = 'center';
                
                // Game ID display
                const gameIdDisplay = document.createElement('div');
                gameIdDisplay.style.fontFamily = 'monospace';
                gameIdDisplay.style.padding = '0.5rem';
                gameIdDisplay.style.backgroundColor = 'var(--light-alt)';
                gameIdDisplay.style.border = '1px solid var(--gray-light)';
                gameIdDisplay.style.borderRadius = 'var(--radius)';
                gameIdDisplay.style.marginBottom = '0.5rem';
                gameIdDisplay.style.wordBreak = 'break-all';
                gameIdDisplay.textContent = gameId;
                
                // Copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn-small';
                copyBtn.innerHTML = '<i class="far fa-copy"></i> Copy Game ID';
                copyBtn.style.margin = '0 auto';
                
                // Feedback element
                const feedbackEl = document.createElement('span');
                feedbackEl.className = 'copy-feedback';
                feedbackEl.id = `qr-copy-feedback-${gameId}`;
                feedbackEl.textContent = 'Copied!';
                feedbackEl.style.display = 'block';
                feedbackEl.style.marginTop = '0.5rem';
                
                // Add click handler for copy button
                copyBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(gameId).then(() => {
                        feedbackEl.classList.add('visible');
                        setTimeout(() => feedbackEl.classList.remove('visible'), 1500);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        alert('Copy failed.');
                    });
                });
                
                // Append elements
                infoContainer.appendChild(gameIdDisplay);
                infoContainer.appendChild(copyBtn);
                infoContainer.appendChild(feedbackEl);
                qrCodeContainer.appendChild(infoContainer);
                
                // Update instructions
                const instructionsDiv = document.querySelector('.qr-code-instructions');
                if (instructionsDiv) {
                    instructionsDiv.innerHTML = `
                        Scan this QR code with your phone's camera or QR scanner app,<br>
                        or copy the game ID manually to join the game.
                    `;
                }
            } catch (err) {
                console.error('Failed to generate QR code:', err);
                qrCodeContainer.innerHTML = '<p>QR code generation failed. Please try again.</p>';
            }
            
            // Show modal
            qrCodeModal.classList.add('active');
            
            // Add close handler
            qrCodeClose.onclick = function() {
                qrCodeModal.classList.remove('active');
            };
            
            // Close on background click
            qrCodeModal.onclick = function(e) {
                if (e.target === qrCodeModal) {
                    qrCodeModal.classList.remove('active');
                }
            };
        }

        // --- Local History Management ---
        function loadLocalHistory() {
            localHistory = JSON.parse(localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY)) || [];
            renderCompletedGames();
        }

        function saveCompletedGameToLocal(finalState, mode) {
            const winners = getWinners(finalState);
            const completedGame = {
                mode: mode, // 'offline' or 'online'
                gameId: (mode === 'online' ? currentGameId : null), // Store online game ID
                date: new Date().toISOString(),
                winners: winners,
                score: winners.length > 0 ? (finalState.scores[winners[0]] || 0) : 0,
                players: [...(finalState.players || [])], // Active players at end
                finalScores: { ...(finalState.scores || {}) },
                eliminatedPlayers: [...(finalState.eliminatedPlayers || [])],
                wasReset: finalState.wasReset || false // Include reset flag if it exists
            };
            localHistory = JSON.parse(localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY)) || [];
            localHistory.push(completedGame);
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(localHistory));
            renderCompletedGames();
        }

        function showGameDetails(gameIndex) {
            const game = localHistory[gameIndex];
            if (!game) return;
            const gameDate = new Date(game.date);
            const formattedDate = `${gameDate.toLocaleDateString()} ${gameDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
            game.eliminatedPlayers = game.eliminatedPlayers || [];
            const allParticipants = [...new Set([...(game.players || []), ...game.eliminatedPlayers])];
            const sortedPlayers = getSortedPlayers(game.finalScores || {}, allParticipants);
            const modeDisplay = game.mode === 'online' ? 'Online' : 'Offline';

            let content = `
                <div class="game-date"><i class="fas fa-calendar-alt"></i> ${formattedDate} (${modeDisplay})</div>
                ${game.gameId ? `<div style="font-size: 0.8rem; color: var(--gray); margin-bottom: 1rem;">Game ID: ${escapeHtml(game.gameId)}</div>` : ''}
                <div class="game-details-winners">
                <h4>${game.winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h4>
                <div class="winner-names">
                    <i class="fas fa-crown"></i> ${game.winners.map(escapeHtml).join(' & ')}
                    <span style="margin-left:auto;">${game.score} points</span>
                </div>
                </div>
                <h4>All Players (${allParticipants.length})</h4>
                <div class="player-scores-container">
                <div class="player-scores-header"><span>Player</span><span>Final Score</span></div>
                <div class="player-scores-list">
            `;
            sortedPlayers.forEach((player, index) => {
                const isWinner = game.winners.includes(player);
                const isEliminated = game.eliminatedPlayers.includes(player);
                const playerScore = game.finalScores[player] || 0;
                content += `
                <div class="player-score-item ${isWinner ? 'winner' : ''} ${isEliminated ? 'eliminated' : ''}">
                    <span class="player-score-name">${index + 1}. ${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</span>
                    <span class="player-score-value">${playerScore}</span>
                </div>`;
            });
            content += `</div></div>`;
            gameDetailsBody.innerHTML = content;
            gameDetailsModal.classList.add('active');
        }

        function closeGameDetailsModal() {
             gameDetailsModal.classList.remove('active');
             gameDetailsBody.innerHTML = ''; // Clear content
        }

        // --- Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js') // Ensure service-worker.js exists
                .then(reg => console.log('Service Worker registered:', reg.scope))
                .catch(err => console.error('Service Worker registration failed:', err));
            });
             navigator.serviceWorker.addEventListener('controllerchange', () => {
                 console.log('Service Worker updated.');
                 // Optional: Add prompt to reload window.location.reload();
             });

             // Add to Home Screen logic (optional but good for PWA)
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                console.log("`beforeinstallprompt` event was fired.");
                // Optionally, show a custom install button here
            });
             window.addEventListener('appinstalled', () => {
                 console.log('PWA was installed');
                 deferredPrompt = null;
            });
        }

        // --- Start the App ---
        initializeApp();

        function isDealer(playerName, currentState) { // Online only helper
             return playerName === getDealerName(currentState);
        }

        // --- Hand-off QR Export/Import Logic ---
        function showHandoffQRModal() {
            const modal = document.getElementById('handoff-qr-modal');
            const container = document.getElementById('handoff-qr-container');
            const closeBtn = document.getElementById('handoff-qr-close');
            if (!modal || !container) return;
            container.innerHTML = '';
            
            // Get offline game state
            let stateStr = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (!stateStr) {
                container.innerHTML = '<p style="color:var(--danger);">No offline game to export.</p>';
                modal.classList.add('active');
                return;
            }
            
            try {
                // Parse and compress the game state for QR export
                const fullState = JSON.parse(stateStr);
                
                // Create a minimal state for hand-off (remove unnecessary data)
                const minimalState = {
                    players: fullState.players || [],
                    gameStarted: fullState.gameStarted || false,
                    currentRound: fullState.currentRound || 1,
                    bids: fullState.bids || {},
                    tricks: fullState.tricks || {},
                    scores: fullState.scores || {},
                    bidPhase: fullState.bidPhase !== false, // default true
                    eliminatedPlayers: fullState.eliminatedPlayers || []
                    // Note: We're excluding roundHistory to save space
                };
                
                const minimalStateStr = JSON.stringify(minimalState);
                // --- COMPRESSION ADDED HERE ---
                const compressed = LZString.compressToEncodedURIComponent(minimalStateStr);
                const qrData = '14HIGHZ:' + compressed;
                // --- END COMPRESSION ---
                
                // Check size before generating QR
                const dataSize = new Blob([qrData]).size;
                console.log(`QR data size: ${dataSize} bytes`);
                
                if (dataSize > 2900) { // Conservative limit
                    container.innerHTML = `
                        <div style="text-align: center; color: var(--danger); padding: 1rem;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                            <p><strong>Game data too large for QR code</strong></p>
                            <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                                Data size: ${dataSize} bytes (limit: ~2900 bytes)<br>
                                Try reducing player names or start a new game.
                            </p>
                            <button onclick="copyGameDataToClipboard()" style="margin-top: 1rem;" class="btn-small">
                                <i class="fas fa-copy"></i> Copy Game Data Instead
                            </button>
                        </div>
                    `;
                    
                    // Add the copy function to window for the button
                    window.copyGameDataToClipboard = function() {
                        navigator.clipboard.writeText(qrData).then(() => {
                            alert('Game data copied to clipboard! Share this text with the other player.');
                        }).catch(err => {
                            console.error('Copy failed:', err);
                            alert('Copy failed. Please try selecting and copying the data manually.');
                        });
                    };
                    
                    modal.classList.add('active');
                    return;
                }
                
                // Generate QR code with lower error correction for more data capacity
                new QRCode(container, {
                    text: qrData,
                    width: 250,
                    height: 250,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.L // Lower error correction = more data capacity
                });
                
                // Add data size info below QR code
                const infoDiv = document.createElement('div');
                infoDiv.style.marginTop = '1rem';
                infoDiv.style.fontSize = '0.8rem';
                infoDiv.style.color = 'var(--gray)';
                infoDiv.style.textAlign = 'center';
                infoDiv.innerHTML = `
                    Data size: ${dataSize} bytes<br>
                    <span style="color: var(--success);"> QR code generated successfully</span>
                `;
                container.appendChild(infoDiv);
                
            } catch (err) {
                console.error('QR generation error:', err);
                container.innerHTML = `
                    <div style="text-align: center; color: var(--danger); padding: 1rem;">
                        <i class="fas fa-times-circle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p><strong>QR code generation failed</strong></p>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                            Error: ${err.message || 'Unknown error'}<br>
                            Please try again or start a new game.
                        </p>
                    </div>
                `;
            }
            
            modal.classList.add('active');
            closeBtn.onclick = () => modal.classList.remove('active');
            modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('active'); };
        }

        function showHandoffImportModal() {
            const modal = document.getElementById('handoff-import-modal');
            const closeBtn = document.getElementById('handoff-import-close');
            const statusEl = document.getElementById('handoff-import-status');
            const qrReaderDiv = document.getElementById('handoff-qr-reader');
            if (!modal || !qrReaderDiv) return;
            statusEl.textContent = 'Position the QR code in the frame...';
            statusEl.style.color = 'var(--gray)';
            qrReaderDiv.innerHTML = '';
            modal.classList.add('active');
            let html5QrCode;
            
            // Function to process import data (QR only)
            function processImportData(decodedText, statusEl, html5QrCode, modal) {
                if (decodedText.startsWith('14HIGHZ:')) {
                    try {
                        const compressed = decodedText.slice(8);
                        const jsonStr = LZString.decompressFromEncodedURIComponent(compressed);
                        const parsed = JSON.parse(jsonStr);
                        
                        // Enhanced validation
                        if (parsed && 
                            Array.isArray(parsed.players) && 
                            typeof parsed.gameStarted === 'boolean' &&
                            typeof parsed.currentRound === 'number' &&
                            parsed.scores && typeof parsed.scores === 'object') {
                            
                            // Restore full game state with defaults for missing data
                            const fullState = {
                                players: parsed.players,
                                gameStarted: parsed.gameStarted,
                                currentRound: parsed.currentRound,
                                bids: parsed.bids || {},
                                tricks: parsed.tricks || {},
                                scores: parsed.scores || {},
                                bidPhase: parsed.bidPhase !== false, // default true
                                eliminatedPlayers: parsed.eliminatedPlayers || [],
                                roundHistory: [] // Reset history since we didn't transfer it
                            };
                            
                            localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(fullState));
                            statusEl.style.color = 'var(--success)';
                            statusEl.textContent = `Game imported! Found ${parsed.players.length} players, Round ${parsed.currentRound}. Loading...`;
                            
                            const closeAndLoad = () => {
                                setTimeout(() => {
                                    modal.classList.remove('active');
                                    selectMode('offline');
                                }, 800);
                            };
                            
                            if (html5QrCode) {
                                html5QrCode.stop().then(closeAndLoad).catch(closeAndLoad);
                            } else {
                                closeAndLoad();
                            }
                        } else {
                            statusEl.style.color = 'var(--danger)';
                            statusEl.textContent = 'Invalid game data format. Missing required fields.';
                            console.error('Invalid game data:', parsed);
                        }
                    } catch (err) {
                        statusEl.style.color = 'var(--danger)';
                        statusEl.textContent = 'Failed to decompress game data: ' + err.message;
                        console.error('Decompression error:', err);
                    }
                } else if (decodedText.startsWith('14HIGH:')) {
                    try {
                        const jsonStr = decodedText.slice(7);
                        const parsed = JSON.parse(jsonStr);
                        // Enhanced validation
                        if (parsed && 
                            Array.isArray(parsed.players) && 
                            typeof parsed.gameStarted === 'boolean' &&
                            typeof parsed.currentRound === 'number' &&
                            parsed.scores && typeof parsed.scores === 'object') {
                            // Restore full game state with defaults for missing data
                            const fullState = {
                                players: parsed.players,
                                gameStarted: parsed.gameStarted,
                                currentRound: parsed.currentRound,
                                bids: parsed.bids || {},
                                tricks: parsed.tricks || {},
                                scores: parsed.scores || {},
                                bidPhase: parsed.bidPhase !== false, // default true
                                eliminatedPlayers: parsed.eliminatedPlayers || [],
                                roundHistory: [] // Reset history since we didn't transfer it
                            };
                            localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(fullState));
                            statusEl.style.color = 'var(--success)';
                            statusEl.textContent = `Game imported! Found ${parsed.players.length} players, Round ${parsed.currentRound}. Loading...`;
                            const closeAndLoad = () => {
                                setTimeout(() => {
                                    modal.classList.remove('active');
                                    selectMode('offline');
                                }, 800);
                            };
                            if (html5QrCode) {
                                html5QrCode.stop().then(closeAndLoad).catch(closeAndLoad);
                            } else {
                                closeAndLoad();
                            }
                        } else {
                            statusEl.style.color = 'var(--danger)';
                            statusEl.textContent = 'Invalid game data format. Missing required fields.';
                            console.error('Invalid game data:', parsed);
                        }
                    } catch (err) {
                        statusEl.style.color = 'var(--danger)';
                        statusEl.textContent = 'Failed to parse game data: ' + err.message;
                        console.error('Parse error:', err);
                    }
                } else {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'Not a 14-High! game QR code.';
                }
            }
            
            // Start QR scanner
            setTimeout(() => {
                if (typeof Html5Qrcode === 'undefined') {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'QR scanner not available.';
                    return;
                }
                
                html5QrCode = new Html5Qrcode("handoff-qr-reader");
                html5QrCode.start(
                    { facingMode: "environment" },
                    { fps: 10, qrbox: 250 },
                    (decodedText, decodedResult) => {
                        processImportData(decodedText, statusEl, html5QrCode, modal);
                    },
                    (errorMessage) => {
                        // Ignore frequent scan errors, but show camera issues
                        if (errorMessage.includes('Camera') || errorMessage.includes('Permission')) {
                            statusEl.style.color = 'var(--warning)';
                            statusEl.textContent = 'Camera issue: ' + errorMessage;
                        }
                    }
                ).catch(err => {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'Camera error: ' + err.message;
                    console.error('Camera error:', err);
                });
            }, 100);
            
            // Close logic
            closeBtn.onclick = () => {
                modal.classList.remove('active');
                if (html5QrCode) html5QrCode.stop().catch(()=>{});
            };
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    if (html5QrCode) html5QrCode.stop().catch(()=>{});
                }
            };
        }

    </script>
</body>
</html>
