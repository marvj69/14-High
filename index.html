<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>14-High! Offline</title>
    <meta name="description" content="Play the 14-High! card game offline with local storage.">
    <meta name="theme-color" content="#4f46e5">
    <link rel="manifest" href="manifest.json"> <!-- Ensure manifest.json exists -->
    <link rel="apple-touch-icon" href="icons/icon-192x192.png"> <!-- Ensure icons exist -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Styles for the offline web app --- */
        :root {
          --primary: #4f46e5; /* Indigo */
          --primary-hover: #4338ca;
          --secondary: #14b8a6; /* Teal */
          --success: #22c55e; /* Green */
          --success-hover: #16a34a;
          --danger: #ef4444; /* Red */
          --danger-hover: #dc2626;
          --warning: #f59e0b; /* Amber */
          --light: #ffffff;
          --light-alt: #f9fafb; /* Very light gray */
          --dark: #111827; /* Dark gray */
          --dark-alt: #1f2937; /* Slightly lighter dark gray */
          --gray: #6b7280; /* Medium gray */
          --gray-light: #e5e7eb; /* Light gray */
          --gray-dark: #374151; /* Darker gray */
          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
          --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
          --radius: 0.375rem; /* 6px */
          --transition: all 0.2s ease-in-out;
          --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        /* Dark mode variables */
        [data-theme="dark"] {
          --primary: #6366f1; /* Lighter Indigo */
          --primary-hover: #818cf8;
          --secondary: #2dd4bf; /* Lighter Teal */
          --success: #4ade80; /* Lighter Green */
          --success-hover: #86efac;
          --danger: #f87171; /* Lighter Red */
          --danger-hover: #fda4af;
          --warning: #fbbf24; /* Lighter Amber */
          --light: #121212; /* Dark background */
          --light-alt: #1e1e1e; /* Slightly lighter dark background */
          --dark: #f8fafc; /* Light text */
          --dark-alt: #e2e8f0; /* Slightly darker light text */
          --gray: #94a3b8; /* Lighter gray */
          --gray-light: #2c2c2c; /* Darker borders/dividers */
          --gray-dark: #3a3a3a; /* Even darker elements */
          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
          --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.4), 0 1px 2px -1px rgb(0 0 0 / 0.4);
          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4);
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        body {
            background-color: var(--light-alt); color: var(--dark); font-family: var(--font-sans);
            line-height: 1.6; padding: 1.5rem; min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { max-width: 700px; margin: 0 auto; }
        #app { margin-top: 4rem; }

        /* Typography */
        h1, h2, h3, h4 { font-weight: 600; line-height: 1.3; margin-bottom: 1rem; color: var(--dark); }
        h1 {
            font-size: 2.25rem; font-weight: 700; text-align: center; position: fixed;
            top: 1rem; left: 50%; transform: translateX(-50%); margin: 0; z-index: 900;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            color: var(--primary); width: auto;
        }
        .fixed-header {
            position: fixed; top: 0; left: 0; right: 0; height: 4rem;
            background-color: var(--light-alt); z-index: 800; box-shadow: var(--shadow);
            transition: background-color 0.3s ease;
        }
        [data-theme="dark"] .fixed-header { background-color: var(--light-alt); }
        h2 { font-size: 1.25rem; margin-bottom: 1rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem; color: var(--dark); }
        h3 { font-size: 1rem; margin-bottom: 0.75rem; font-weight: 500; color: var(--gray); }

        /* Card styles */
        .card {
            background-color: var(--light); border-radius: var(--radius); box-shadow: var(--shadow);
            padding: 1.25rem 1.5rem; margin-bottom: 1.5rem; border: 1px solid var(--gray-light);
            transition: var(--transition);
        }
        [data-theme="dark"] .card { background-color: var(--light-alt); border-color: var(--gray-dark); }

        /* Form elements */
        .input-group { display: flex; margin-bottom: 1rem; position: relative; }
        input, button { font-size: 0.9375rem; font-family: inherit; transition: var(--transition); }
        input[type="text"], input[type="number"] {
            flex-grow: 1; padding: 0.625rem 0.875rem; border: 1px solid var(--gray-light);
            border-radius: var(--radius); background-color: var(--light); color: var(--dark);
            outline: none; box-shadow: var(--shadow-sm);
        }
        [data-theme="dark"] input[type="text"], [data-theme="dark"] input[type="number"] {
            background-color: var(--gray-dark); border-color: var(--gray-dark); color: var(--dark);
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--primary); box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        [data-theme="dark"] input[type="text"]:focus, [data-theme="dark"] input[type="number"]:focus {
            border-color: var(--primary); box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }
        input[type="number"] {
            width: 4.5rem; text-align: center; -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .input-with-button { display: flex; width: 100%; }
        .input-with-button input { border-radius: var(--radius) 0 0 var(--radius); border-right: none; }
        button {
            padding: 0.625rem 1rem; border: none; border-radius: var(--radius);
            background-color: var(--primary); color: white; cursor: pointer; font-weight: 500;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.375rem;
            transition: var(--transition); white-space: nowrap;
        }
        button:hover:not(:disabled) { background-color: var(--primary-hover); transform: translateY(-1px); box-shadow: var(--shadow-sm); }
        button:active:not(:disabled) { transform: translateY(0); box-shadow: none; }
        button:disabled { background-color: var(--gray-light); color: var(--gray); cursor: not-allowed; opacity: 0.7; }
        [data-theme="dark"] button:disabled { background-color: var(--gray-dark); color: var(--gray); }
        .btn-add { border-radius: 0 var(--radius) var(--radius) 0; }
        .btn-full { display: block; width: 100%; margin-top: 0.75rem; padding: 0.75rem; }
        .btn-green { background-color: var(--success); }
        .btn-green:hover:not(:disabled) { background-color: var(--success-hover); }
        .btn-red { background-color: var(--danger); }
        .btn-red:hover:not(:disabled) { background-color: var(--danger-hover); }
        .btn-outline { background-color: transparent; border: 1px solid var(--gray-light); color: var(--primary); }
        .btn-outline:hover:not(:disabled) { background-color: rgba(79, 70, 229, 0.05); border-color: var(--primary); }
        [data-theme="dark"] .btn-outline { border-color: var(--gray-dark); color: var(--primary); }
        [data-theme="dark"] .btn-outline:hover:not(:disabled) { background-color: rgba(99, 102, 241, 0.1); border-color: var(--primary); }

        /* Player list */
        .player-list { margin: 0.75rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        .player-item {
            display: flex; justify-content: space-between; align-items: center; background-color: var(--light-alt);
            padding: 0.625rem 1rem; border-radius: var(--radius); border: 1px solid var(--gray-light); transition: var(--transition);
        }
        .player-item span { font-weight: 500; }
        [data-theme="dark"] .player-item { background-color: var(--light); border-color: var(--gray-dark); }
        .btn-remove {
  background: none; color: var(--danger); padding: 0.25rem; border-radius: 50%;
  width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center;
}
.btn-move-up, .btn-move-down {
  background: none;
  color: var(--primary);
  padding: 0.25rem;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  transition: background 0.15s;
}
.btn-move-up:disabled, .btn-move-down:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.btn-move-up:hover:not(:disabled), .btn-move-down:hover:not(:disabled) {
  background: rgba(79, 70, 229, 0.08);
  color: var(--success);
}
        .btn-remove:hover { background: rgba(239, 68, 68, 0.1); color: var(--danger-hover); transform: none; box-shadow: none; }

        /* Tables */
        .table-container { overflow-x: auto; margin-bottom: 1.5rem; border-radius: var(--radius); border: 1px solid var(--gray-light); background-color: var(--light); }
        [data-theme="dark"] .table-container { border-color: var(--gray-dark); }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        [data-theme="dark"] table { background-color: var(--light-alt); }
        th {
            text-align: left; padding: 0.75rem 1rem; background-color: var(--light-alt); font-weight: 500; color: var(--gray);
            text-transform: uppercase; letter-spacing: 0.05em; font-size: 0.75rem; border-bottom: 1px solid var(--gray-light);
        }
        td { padding: 0.875rem 1rem; border-bottom: 1px solid var(--gray-light); vertical-align: middle; color: var(--dark); }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: rgba(79, 70, 229, 0.03); }
        [data-theme="dark"] th { background-color: var(--light); border-bottom-color: var(--gray-dark); color: var(--gray); }
        [data-theme="dark"] td { border-bottom-color: var(--gray-dark); color: var(--dark-alt); }
        [data-theme="dark"] tbody tr:last-child td { border-bottom: none; }
        [data-theme="dark"] tbody tr:hover { background-color: rgba(99, 102, 241, 0.05); }
        td:last-child { font-weight: 600; }
        .winner-row { background-color: rgba(34, 197, 94, 0.05) !important; border-left: 3px solid var(--success); position: relative; }
        .winner-row td:first-child { padding-left: calc(1rem - 3px); }
        [data-theme="dark"] .winner-row { background-color: rgba(74, 222, 128, 0.08) !important; }

        /* Winner display */
        .winner-display {
            margin-bottom: 2rem; text-align: center; background-color: var(--light-alt); padding: 1.5rem;
            border-radius: var(--radius); border: 1px solid var(--gray-light);
        }
        [data-theme="dark"] .winner-display { background-color: var(--dark-alt); border-color: var(--gray-dark); }
        .winner-display h3 { color: var(--gray); margin-bottom: 0.5rem; }
        .winner-name { font-size: 1.5rem; font-weight: 600; color: var(--success); margin-top: 0.25rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .winner-name .fa-crown { color: var(--warning); }

        /* Layout utilities */
        .flex-between { display: flex; justify-content: space-between; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .game-status {
            display: inline-block; font-size: 0.8rem; font-weight: 500; padding: 0.25rem 0.625rem; border-radius: 100px;
            background-color: rgba(79, 70, 229, 0.1); color: var(--primary); margin-bottom: 0.5rem;
        }
        [data-theme="dark"] .game-status { background-color: rgba(99, 102, 241, 0.15); color: var(--primary); }
        .badge { display: inline-block; padding: 0.25rem 0.625rem; border-radius: var(--radius); font-size: 0.8rem; font-weight: 500; margin-left: 0.5rem; }
        .badge-blue { background-color: rgba(79, 70, 229, 0.1); color: var(--primary); }
        .badge-green { background-color: rgba(34, 197, 94, 0.1); color: var(--success); }
        [data-theme="dark"] .badge-blue { background-color: rgba(99, 102, 241, 0.2); }
        [data-theme="dark"] .badge-green { background-color: rgba(74, 222, 128, 0.2); }
        .trick-value { display: flex; align-items: center; justify-content: flex-start; }
        .score-value { font-weight: 600; color: var(--primary); }
        .player-name { display: inline-flex; align-items: center; gap: 0.35rem; flex-wrap: wrap; }
        .dealer-badge, .lead-badge {
            display: inline-flex; align-items: center; gap: 0.25rem;
            font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;
        }
        .dealer-badge { color: var(--warning); }
        .lead-badge { color: var(--secondary); }

        /* Hamburger menu styles */
        .hamburger-menu { position: fixed; top: 1rem; left: 1rem; z-index: 1000; }
        .hamburger-btn, .menu-close {
            background: var(--light); border: 1px solid var(--gray-light); color: var(--gray); cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px;
            border-radius: 50%; transition: var(--transition); padding: 0; font-size: 1rem; box-shadow: var(--shadow);
        }
        .hamburger-btn:hover, .menu-close:hover { background: var(--light-alt); color: var(--primary); transform: scale(1.05); box-shadow: var(--shadow-md); }
        [data-theme="dark"] .hamburger-btn, [data-theme="dark"] .menu-close { background: var(--light); border-color: var(--gray-dark); color: var(--gray); }
        [data-theme="dark"] .hamburger-btn:hover, [data-theme="dark"] .menu-close:hover { background: var(--light-alt); color: var(--primary); }
        .menu-content {
            position: fixed; top: 0; left: -250px; width: 250px; height: 100%; background-color: var(--light);
            box-shadow: var(--shadow-md); transition: left 0.3s ease; padding: 1rem; display: flex; flex-direction: column;
            border-right: 1px solid var(--gray-light); z-index: 1001; /* Ensure menu above overlay */
        }
        [data-theme="dark"] .menu-content { background-color: var(--light-alt); border-right-color: var(--gray-dark); }
        .menu-content.active { left: 0; }
        .menu-header { display: flex; justify-content: flex-end; margin-bottom: 1.5rem; padding-top: 0.5rem; }
        .menu-item-header {
            padding: 0.5rem 0; margin: 1rem 0 0.5rem 0; font-weight: 600; font-size: 0.8rem; color: var(--gray);
            text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid var(--gray-light);
            display: flex; align-items: center; gap: 0.5rem;
        }
        [data-theme="dark"] .menu-item-header { border-color: var(--gray-dark); color: var(--gray); }
        .menu-item {
            padding: 0.75rem 0.5rem; margin: 0.25rem 0; border-radius: var(--radius); cursor: pointer; transition: var(--transition);
            display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;
        }
        .menu-item span { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .menu-item:hover { background-color: var(--light-alt); }
        [data-theme="dark"] .menu-item:hover { background-color: var(--light); }
        .completed-games-list { flex-grow: 1; overflow-y: auto; margin: 0.5rem 0; padding-right: 0.5rem; }
        .completed-games-list::-webkit-scrollbar { width: 6px; }
        .completed-games-list::-webkit-scrollbar-track { background: transparent; }
        .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-light); border-radius: 3px; }
        [data-theme="dark"] .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-dark); }
        .completed-game-item {
            padding: 0.75rem 1rem; margin: 0.5rem 0; background-color: var(--light-alt); border-radius: var(--radius);
            border-left: 3px solid var(--primary); transition: var(--transition); font-size: 0.85rem; cursor: pointer;
        }
        .completed-game-item:hover { transform: translateX(3px); background-color: var(--light); box-shadow: var(--shadow-sm); }
        [data-theme="dark"] .completed-game-item { background-color: var(--gray-dark); border-color: var(--primary); }
        [data-theme="dark"] .completed-game-item:hover { background-color: var(--light-alt); }
        .completed-game-item div { margin: 0.2rem 0; display: flex; align-items: center; gap: 0.5rem; color: var(--gray); }
        .completed-game-item div i { width: 14px; text-align: center; }
        .game-winner { color: var(--success) !important; font-weight: 500; }
        .game-score { color: var(--primary) !important; font-weight: 500; }
        [data-theme="dark"] .game-winner { color: var(--success) !important; }
        [data-theme="dark"] .game-score { color: var(--primary) !important; }
        .no-games { padding: 1rem; text-align: center; color: var(--gray); font-style: italic; font-size: 0.9rem; }

        /* Toggle switch */
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--gray-light); transition: .3s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; box-shadow: var(--shadow-sm); }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }
        [data-theme="dark"] .slider { background-color: var(--gray-dark); }

        /* Game Info / Validation Messages */
        .game-info {
            margin-bottom: 0.75rem; padding: 0.5rem 1rem; background-color: var(--light-alt); border-radius: var(--radius);
            border: 1px solid var(--gray-light); color: var(--gray); font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem; min-height: 36px;
        }
        [data-theme="dark"] .game-info { background-color: var(--light); border-color: var(--gray-dark); }
        .game-info.bid-warning, .game-info.trick-warning { border-left: 3px solid var(--danger); color: var(--danger); background-color: rgba(239, 68, 68, 0.05); }
        [data-theme="dark"] .game-info.bid-warning, [data-theme="dark"] .game-info.trick-warning { background-color: rgba(248, 113, 113, 0.1); }
        .game-info.bid-ok, .game-info.trick-ok { border-left: 3px solid var(--success); color: var(--success); background-color: rgba(34, 197, 94, 0.05); }
        [data-theme="dark"] .game-info.bid-ok, [data-theme="dark"] .game-info.trick-ok { background-color: rgba(74, 222, 128, 0.08); }

        /* Elimination banner */
        .elimination-banner {
            background-color: var(--primary); color: white; padding: 0.2rem 0.5rem; border-radius: var(--radius);
            font-weight: 500; box-shadow: var(--shadow); text-align: center; display: flex; align-items: center; gap: 0.25rem;
            border: 1px solid rgba(0,0,0,0.1); font-size: 0.75rem; white-space: nowrap;
        }
        #elimination-banner { 
            position: fixed; top: 4.5rem; left: 50%; transform: translateX(-50%); z-index: 850; 
            animation: fadeInFixed 0.3s ease-in-out; 
        }
        #round-elimination-banner { 
            z-index: 100; /* Inline banner */
            animation: none; /* Remove animation for inline banner to prevent jerking */
        }
        @keyframes fadeInFixed { from { opacity: 0; transform: translate(-50%, -10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        [data-theme="dark"] .elimination-banner { background-color: var(--primary); color: white; }
        .elimination-banner i { font-size: 0.7rem; }

        .button-group { display: flex; gap: 0.75rem; flex-wrap: wrap; }
        .flex-between > p { color: var(--gray); font-size: 0.9rem; margin-top: 0.25rem; }
        *:focus { outline: none; }
        *:focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; border-radius: var(--radius); }
        input:focus-visible, button:focus-visible, .toggle-switch:focus-within { outline: none; }
        button:focus-visible { box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4); }
        [data-theme="dark"] button:focus-visible { box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5); }

        /* Responsive */
        @media (max-width: 640px) {
            body { padding: 1rem; }
            h1 { font-size: 1.875rem; width: 80%; line-height: 1.2; }
            .card { padding: 1.25rem; }
            .flex-between { flex-direction: column; align-items: stretch; }
            .flex-between > .button-group { width: 100%; justify-content: center; }
            .flex-between > p { text-align: center; width: 100%; margin-top: 0.5rem; }
            th, td { padding: 0.75rem 0.5rem; }
            input[type="number"] { width: 3.8rem; padding: 0.625rem 0.5rem; }
            td { font-size: 0.85rem; }
        }

        /* Touch device hover reset */
        @media (hover: none) {
            button:hover:not(:disabled), .btn-remove:hover, .btn-green:hover:not(:disabled), .btn-red:hover:not(:disabled),
            .btn-outline:hover:not(:disabled), .menu-item:hover, .completed-game-item:hover, .hamburger-btn:hover,
            .menu-close:hover, tbody tr:hover {
                background-color: inherit; color: inherit; transform: none; box-shadow: none; border-color: inherit;
            }
            button:hover:not(:disabled) { background-color: var(--primary); }
            .btn-green:hover:not(:disabled) { background-color: var(--success); }
            .btn-red:hover:not(:disabled) { background-color: var(--danger); }
            .btn-outline:hover:not(:disabled) { background-color: transparent; color: var(--primary); }
            .btn-remove:hover { background: none; color: var(--danger); }
            .completed-game-item:hover { transform: none; background-color: var(--light-alt); }
            [data-theme="dark"] .completed-game-item:hover { background-color: var(--light); }
            [data-theme="dark"] .menu-item:hover { background-color: transparent; }
        }

        /* Version indicator & modal */
        .version-badge {
            position: fixed; top: 1.25rem; right: 1rem; z-index: 900; background-color: var(--light); color: var(--primary);
            border: 1px solid var(--gray-light); border-radius: var(--radius); padding: 0.25rem 0.5rem;
            font-size: 0.75rem; font-weight: 500; box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition);
        }
        .version-badge:hover { background-color: var(--light-alt); box-shadow: var(--shadow); transform: translateY(-2px); }
        .version-modal {
            position: fixed; top: 3.5rem; right: 1rem; z-index: 950; background-color: var(--light);
            border: 1px solid var(--gray-light); border-radius: var(--radius); padding: 1rem; width: 300px;
            max-width: calc(100vw - 2rem); box-shadow: var(--shadow-md); opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0.2s;
        }
        .version-modal.active { opacity: 1; visibility: visible; transform: translateY(0); transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0s; }
        .version-title { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .version-title h3 { margin: 0; color: var(--dark); }
        .version-modal .close-btn {
            background: none; color: var(--gray); padding: 0.25rem; border-radius: 50%; width: 22px; height: 22px; min-width: 22px;
            display: inline-flex; align-items: center; justify-content: center; cursor: pointer; border: none;
        }
        .version-modal .close-btn:hover { color: var(--dark); background-color: var(--gray-light); }
        .version-info { font-size: 0.9rem; color: var(--gray-dark); }
        .version-info p { margin: 0.5rem 0; }
        .version-info ul { margin: 0.5rem 0; padding-left: 1.5rem; }
        .version-info li { margin: 0.25rem 0; }
        [data-theme="dark"] .version-badge { background-color: var(--light-alt); border-color: var(--gray-dark); }
        [data-theme="dark"] .version-badge:hover { background-color: var(--light); }
        [data-theme="dark"] .version-modal { background-color: var(--light-alt); border-color: var(--gray-dark); }
        [data-theme="dark"] .version-modal .close-btn:hover { background-color: var(--gray-dark); color: var(--light); }
        [data-theme="dark"] .version-info { color: var(--dark-alt); }

        /* Eliminated player style */
        .eliminated-player { text-decoration: line-through; opacity: 0.7; color: var(--gray); }
        [data-theme="dark"] .eliminated-player { opacity: 0.6; }

        /* Game Details Modal */
        .game-details-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center; z-index: 1100; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .game-details-modal.active { opacity: 1; visibility: visible; }
        .game-details-content {
            background-color: var(--light); border-radius: var(--radius); width: 90%; max-width: 500px; max-height: 90vh;
            overflow-y: auto; padding: 1.5rem; position: relative; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        [data-theme="dark"] .game-details-content {
            background-color: var(--light-alt);
        }
        .game-details-close {
            position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; color: var(--gray);
            font-size: 1.25rem; transition: color 0.2s ease;
        }
        .game-details-close:hover { color: var(--danger); }

        /* QR Code Modal */
        .qr-code-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center; z-index: 1100; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .qr-code-modal.active { opacity: 1; visibility: visible; }
        .qr-code-content {
            background-color: var(--light); border-radius: var(--radius); width: 90%; max-width: 350px; max-height: 90vh;
            overflow-y: auto; padding: 1.5rem; position: relative; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        [data-theme="dark"] .qr-code-content {
            background-color: var(--light-alt);
        }
        .qr-code-close {
            position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; color: var(--gray);
            font-size: 1.25rem; transition: color 0.2s ease;
        }
        .qr-code-close:hover { color: var(--danger); }
        .qr-code-container {
            margin: 1rem 0;
            display: flex;
            justify-content: center;
        }
        .qr-code-instructions {
            font-size: 0.9rem;
            color: var(--gray);
            margin-top: 1rem;
        }
        .qr-code-content h3 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }
        .qr-code-text {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--primary);
            margin-top: 0.75rem;
            word-break: break-all;
            text-align: center;
        }
        #copy-qr-id-btn {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--success);
            border: none;
            background: none;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        #copy-qr-id-btn:hover {
            color: var(--success-light);
        }

        .copy-feedback { margin-left: 0.5rem; font-size: 0.8rem; color: var(--success); opacity: 0; transition: opacity 0.3s ease; }
        .copy-feedback.visible { opacity: 1; }
        .error-message { color: var(--danger); font-size: 0.85rem; margin-top: -0.5rem; margin-bottom: 0.75rem; text-align: center; display: block; min-height: 1.2em; }

        /* Leave/Back Button */
        .btn-leave-game, .btn-back-to-menu {
            background-color: var(--gray); margin-right: 1rem;
        }
        .btn-leave-game:hover:not(:disabled), .btn-back-to-menu:hover:not(:disabled) {
            background-color: var(--gray-dark);
        }
        [data-theme="dark"] .btn-leave-game, [data-theme="dark"] .btn-back-to-menu {
            background-color: var(--gray-dark);
        }
        [data-theme="dark"] .btn-leave-game:hover:not(:disabled), [data-theme="dark"] .btn-back-to-menu:hover:not(:disabled) {
            background-color: var(--gray);
        }

        /* Mode Selection Screen */
        .mode-selection-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            gap: 1.5rem;
        }
        .mode-selection-container .card {
             width: 100%;
             max-width: 400px; /* Limit width of choice cards */
             text-align: center;
        }
         .mode-selection-container .card h3 {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
         }
         .mode-selection-container .card p {
            color: var(--gray);
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            min-height: 3em; /* Ensure cards have similar height */
         }

        /* Button Styles */
        .btn-small {
            background-color: var(--gray-light);
            color: var(--gray);
            border: none;
            border-radius: var(--radius);
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }
        .btn-small:hover {
            background-color: var(--gray);
            color: var(--light);
        }
        [data-theme="dark"] .btn-small {
            background-color: var(--gray-dark);
            color: var(--light);
        }
        [data-theme="dark"] .btn-small:hover {
            background-color: var(--gray);
        }

        /* QR code small button */
        #show-qr-btn {
            padding: 0.5rem 0.7rem;
            font-size: 0.85rem;
            margin-left: 0.5rem;
            height: 2.3rem;
            width: 2.3rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
        }

        /* Text button for copy */
        .btn-text {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--primary);
            transition: color 0.2s ease;
            padding: 0;
            margin: 0;
        }
        .btn-text:hover {
            color: var(--success);
        }
        [data-theme="dark"] .btn-text {
            color: var(--primary-light);
        }
        [data-theme="dark"] .btn-text:hover {
            color: var(--success);
        }

        /* Game Details Modal Content Styles */
        .game-details-content h4 {
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
        }
        .game-date {
            font-size: 0.9rem;
            color: var(--gray);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .winner-names {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--light-alt);
            padding: 0.5rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }
        .winner-names .fa-crown {
            margin-right: 0.5rem;
            color: var(--warning);
        }
        .player-scores-container {
            margin-top: 1rem;
        }
        .player-scores-header {
            display: flex;
            font-weight: 600;
            color: var(--dark-alt);
            border-bottom: 1px solid var(--gray-light);
            padding: 0.5rem 0;
        }
        .player-scores-header span {
            flex: 1;
            text-transform: uppercase;
            font-size: 0.85rem;
        }
        .player-score-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--gray-light);
        }
        .player-score-item:last-child {
            border-bottom: none;
        }
        .player-score-item span {
            flex: 1;
        }
        .player-score-value {
            font-weight: 600;
            color: var(--primary);
            text-align: right;
        }
        .player-score-item.winner {
            background-color: rgba(34, 197, 94, 0.1);
        }
        .player-score-item.eliminated {
            opacity: 0.6;
        }
        [data-theme="dark"] .player-scores-header {
            border-color: var(--gray-dark);
            color: var(--gray);
        }
        [data-theme="dark"] .player-score-item {
            border-color: var(--gray-dark);
        }
        [data-theme="dark"] .player-score-item.winner {
            background-color: rgba(74, 222, 128, 0.1);
        }
    </style>
    <!-- QR Code library (changed to CDN version) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Compression helpers for QR hand-off payloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <!-- Add html5-qrcode for QR scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
</head>
<body data-theme="light">
    <!-- Game Details Modal -->
    <div id="game-details-modal" class="game-details-modal">
      <div class="game-details-content">
        <button id="game-details-close" class="game-details-close" aria-label="Close game details"><i class="fas fa-times"></i></button>
        <div id="game-details-body"></div>
      </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-code-modal" class="qr-code-modal">
      <div class="qr-code-content">
        <button id="qr-code-close" class="qr-code-close" aria-label="Close QR code"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Game QR Code</h3>
        <div class="qr-code-container" id="qr-code-container"></div>
        <div class="qr-code-text" id="qr-code-text"></div>
        <button id="copy-qr-id-btn" class="btn-text">Copy Game ID</button>
        <div class="qr-code-instructions">
          Other players can scan this QR code with their phone to automatically join your game
        </div>
      </div>
    </div>

    <!-- Hand-off QR Export Modal (for offline game state) -->
    <div id="handoff-qr-modal" class="qr-code-modal">
      <div class="qr-code-content">
        <button id="handoff-qr-close" class="qr-code-close" aria-label="Close hand-off QR"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Hand-off Game (QR)</h3>
        <div class="qr-code-container" id="handoff-qr-container"></div>
        <div class="qr-code-instructions">
          Transfer your offline game to another device by scanning this QR code.<br>
          <span style="font-size:0.85em;color:var(--gray);">Game state is compressed to fit in QR code - round history may be lost.</span>
        </div>
      </div>
    </div>

    <!-- Hand-off QR Import Modal (for scanning QR) -->
    <div id="handoff-import-modal" class="qr-code-modal">
      <div class="qr-code-content" style="max-width:450px;">
        <button id="handoff-import-close" class="qr-code-close" aria-label="Close import QR"><i class="fas fa-times"></i></button>
        <h3><i class="fas fa-qrcode"></i> Import Game from QR</h3>
        <div style="font-size: 0.9rem; color: var(--gray); margin-bottom: 1rem; text-align: center;">
          Scan a hand-off QR code from another device.
        </div>
        <div id="handoff-qr-reader" style="width:100%;margin:0 auto;"></div>
        <div id="handoff-import-status" style="margin-top:1rem;color:var(--gray);"></div>
      </div>
    </div>

    <div class="fixed-header"></div>
    <div class="hamburger-menu">
        <button class="hamburger-btn" aria-label="Open menu"><i class="fas fa-bars"></i></button>
        <div class="menu-content">
            <div class="menu-header">
                <button class="menu-close" aria-label="Close menu"><i class="fas fa-times"></i></button>
            </div>

            <div class="menu-item-header"><i class="fas fa-cog"></i> Settings</div>
            <div class="menu-item">
                <span><i class="fas fa-moon"></i> Dark Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="dark-mode-toggle" aria-label="Toggle dark mode">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="menu-item menu-item-back-to-menu" id="menu-back-button" style="display: none;">
                 <span><i class="fas fa-arrow-left"></i> Back to Start</span>
            </div>

            <div class="menu-item-header"><i class="fas fa-history"></i> Game History</div>
            <div class="completed-games-list" id="completed-games-list">
                <div class="no-games"><i class="fas fa-info-circle"></i> Loading history...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>14-High!</h1>
        <div id="app">
            <!-- Initial content: Mode Selection Screen -->
            <!-- Will be replaced by JS -->
        </div>
    </div>

    <!-- Elimination notification banner (initially hidden) -->
    <div id="elimination-banner" class="elimination-banner" style="display: none;">
        <i class="fas fa-exclamation-triangle"></i>
        <span id="elimination-message">Upcoming elimination</span>
    </div>

    <!-- Version indicator -->
    <div class="version-badge" id="version-badge">
        <span>v2.1.0</span> <!-- Updated Version -->
    </div>
    <div class="version-modal" id="version-modal">
        <div class="version-title">
            <h3>14-High!</h3>
            <button class="close-btn" id="version-close" aria-label="Close version info">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="version-info">
            <p><strong>Released:</strong> April 2025</p>
            <p><strong>What's New:</strong></p>
            <ul>
                <li><i class="fas fa-gamepad"></i> Streamlined for fast local play.</li>
                <li><i class="fas fa-hdd"></i> Progress saved automatically in the browser.</li>
                <li>Includes history, dark mode, and QR hand-off tools.</li>
                <li>Author: Mark Heinonen</li>
                <li>(906) 299-2350</li>

            </ul>
        </div>
    </div>
    <script>
        // --- Constants & Config ---
        const MAX_PLAYERS = 56;
        const ELIMINATION_THRESHOLD = 56;
        const LOCAL_STORAGE_OFFLINE_KEY = 'offlineGameState';
        const LOCAL_STORAGE_HISTORY_KEY = 'completedGames';
        const LOCAL_STORAGE_THEME_KEY = 'theme';

        // --- Global State ---
        let currentMode = 'entry'; // 'entry' or 'offline'
        let offlineState = {};
        let localHistory = [];
        let previousHtml = ''; // Track previous HTML for diffing
        let darkMode = false;

        // --- DOM Elements ---
        const app = document.getElementById('app');
        const hamburgerBtn = document.querySelector('.hamburger-btn');
        const menuContent = document.querySelector('.menu-content');
        const menuClose = document.querySelector('.menu-close');
        const menuBackButton = document.getElementById('menu-back-button');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const completedGamesList = document.getElementById('completed-games-list');
        const body = document.body;
        const versionBadge = document.getElementById('version-badge');
        const versionModal = document.getElementById('version-modal');
        const versionClose = document.getElementById('version-close');
        const eliminationBanner = document.getElementById('elimination-banner');
        const gameDetailsModal = document.getElementById('game-details-modal');
        const gameDetailsClose = document.getElementById('game-details-close');
        const gameDetailsBody = document.getElementById('game-details-body');

        // --- Initialization ---
        function initializeApp() {
            const savedTheme = localStorage.getItem(LOCAL_STORAGE_THEME_KEY);
            if (savedTheme === 'dark') {
                darkMode = true;
                if (darkModeToggle) darkModeToggle.checked = true;
                applyTheme('dark');
            } else {
                applyTheme('light');
            }

            loadLocalHistory();
            renderApp();
            menuBackButton.style.display = 'none';

            app.addEventListener('click', handleAppClick);
            app.addEventListener('keypress', handleAppKeyPress);
            app.addEventListener('input', handleAppInput);
            app.addEventListener('focusin', (e) => {
                if (e.target.matches('input[type=\"number\"], input[type=\"text\"]')) {
                    e.target.select();
                }
            });

            hamburgerBtn.addEventListener('click', () => menuContent.classList.add('active'));
            menuClose.addEventListener('click', () => menuContent.classList.remove('active'));
            menuBackButton.addEventListener('click', goBackToEntry);

            document.addEventListener('click', (e) => {
                if (menuContent.classList.contains('active') && !menuContent.contains(e.target) && !hamburgerBtn.contains(e.target)) {
                    menuContent.classList.remove('active');
                }
                if (versionModal.classList.contains('active') && !versionModal.contains(e.target) && !versionBadge.contains(e.target)) {
                    versionModal.classList.remove('active');
                }
                if (gameDetailsModal.classList.contains('active') && e.target === gameDetailsModal) {
                    closeGameDetailsModal();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (menuContent.classList.contains('active')) menuContent.classList.remove('active');
                    if (versionModal.classList.contains('active')) versionModal.classList.remove('active');
                    if (gameDetailsModal.classList.contains('active')) closeGameDetailsModal();
                }
            });

            if (darkModeToggle) {
                darkModeToggle.addEventListener('change', () => applyTheme(darkModeToggle.checked ? 'dark' : 'light'));
            }

            if (versionBadge) {
                versionBadge.addEventListener('click', (e) => {
                    e.stopPropagation();
                    versionModal.classList.add('active');
                });
            }
            if (versionClose) {
                versionClose.addEventListener('click', () => versionModal.classList.remove('active'));
            }

            if (gameDetailsClose) {
                gameDetailsClose.addEventListener('click', closeGameDetailsModal);
            }
            if (completedGamesList) {
                completedGamesList.addEventListener('click', (e) => {
                    const gameItem = e.target.closest('.completed-game-item');
                    if (gameItem) {
                        const gameIndex = parseInt(gameItem.getAttribute('data-game-index'));
                        if (!isNaN(gameIndex)) showGameDetails(gameIndex);
                    }
                });
            }
            if (gameDetailsModal) {
                gameDetailsModal.addEventListener('click', (e) => {
                    if (e.target === gameDetailsModal) closeGameDetailsModal();
                });
            }

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && currentMode === 'offline' && offlineState.gameStarted) {
                    checkUpcomingElimination(offlineState);
                }
            });

            if (eliminationBanner) {
                eliminationBanner.addEventListener('click', (e) => {
                    if (e.target.closest('.elimination-dismiss')) {
                        eliminationBanner.style.display = 'none';
                    }
                });
            }

            document.body.addEventListener('click', (e) => {
                if (e.target.closest('#handoff-qr-btn')) {
                    showHandoffQRModal();
                }
                if (e.target.closest('#handoff-import-btn')) {
                    showHandoffImportModal();
                }
            });
        }

        // --- Mode Selection & Switching ---
        function selectMode(mode) {
            hideEliminationBanner();
            if (mode === 'offline') {
                currentMode = 'offline';
                loadOfflineState();
                menuBackButton.style.display = 'block';
                renderApp();
            } else { // Go back to entry
                currentMode = 'entry';
                offlineState = {}; // Clear offline state
                menuBackButton.style.display = 'none';
                renderApp();
            }
        }

        // Check if there's a saved offline game in localStorage
        function hasSavedOfflineGame() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (!savedState) return false;
            
            try {
                const state = JSON.parse(savedState);
                // Check if the game was actually started and has players
                return state.gameStarted && state.players && state.players.length >= 2;
            } catch (err) {
                console.error('Error checking saved offline game:', err);
                return false;
            }
        }

        function goBackToEntry() {
            if (currentMode === 'offline') {
                if (!offlineState.gameStarted || confirm("Are you sure you want to leave this offline game? Progress might be saved.")) {
                    selectMode('entry');
                }
            } else {
                selectMode('entry');
            }
            menuContent.classList.remove('active');
        }
        // --- Event Handlers (Delegated) ---
        function handleAppClick(e) {
            const target = e.target;

            if (target.closest('#select-offline-btn')) {
                selectMode('offline');
                return;
            }

            if (target.closest('#back-to-menu-btn')) {
                goBackToEntry();
                return;
            }

            if (currentMode !== 'offline') {
                return;
            }

            if (!offlineState.gameStarted) {
                if (target.closest('#add-player-btn')) {
                    addPlayerOffline();
                    return;
                }

                const removeBtn = target.closest('.btn-remove');
                if (removeBtn) {
                    const player = removeBtn.getAttribute('data-player');
                    if (player) removePlayerOffline(player);
                    return;
                }

                const moveUpBtn = target.closest('.btn-move-up');
                if (moveUpBtn) {
                    const player = moveUpBtn.getAttribute('data-player');
                    if (player) {
                        const idx = offlineState.players.indexOf(player);
                        if (idx > 0) {
                            [offlineState.players[idx - 1], offlineState.players[idx]] = [offlineState.players[idx], offlineState.players[idx - 1]];
                            saveOfflineState();
                            renderApp();
                        }
                    }
                    return;
                }

                const moveDownBtn = target.closest('.btn-move-down');
                if (moveDownBtn) {
                    const player = moveDownBtn.getAttribute('data-player');
                    if (player) {
                        const idx = offlineState.players.indexOf(player);
                        if (idx !== -1 && idx < offlineState.players.length - 1) {
                            [offlineState.players[idx + 1], offlineState.players[idx]] = [offlineState.players[idx], offlineState.players[idx + 1]];
                            saveOfflineState();
                            renderApp();
                        }
                    }
                    return;
                }

                if (target.closest('#start-game-btn')) {
                    startGameOffline();
                    return;
                }
            } else {
                if (target.closest('#submit-bids-btn')) {
                    submitBidsOffline();
                    return;
                }
                if (target.closest('#submit-results-btn')) {
                    submitRoundResultsOffline();
                    return;
                }
                if (target.closest('#reset-game-btn')) {
                    resetGameOffline();
                    return;
                }
                if (target.closest('#undo-round-btn')) {
                    undoRoundOffline();
                    return;
                }
            }

            if (target.closest('#leave-game-btn')) {
                goBackToEntry();
            }
        }

        function handleAppKeyPress(e) {
            if (e.key !== 'Enter') return;

            if (currentMode !== 'offline') return;

            if (!offlineState.gameStarted && e.target.id === 'player-name') {
                e.preventDefault();
                addPlayerOffline();
                return;
            }

            if (!offlineState.gameStarted) return;

            const bidInput = e.target.closest('.bid-input');
            const trickInput = e.target.closest('.trick-input');

            if (bidInput && offlineState.bidPhase && !bidInput.disabled) {
                e.preventDefault();
                const allEnabledBidInputs = Array.from(app.querySelectorAll('.bid-input:not([disabled])'));
                const currentIndex = allEnabledBidInputs.findIndex(input => input === bidInput);
                const nextInput = allEnabledBidInputs[currentIndex + 1];

                if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                } else if (allBidsEntered(offlineState)) {
                    submitBidsOffline();
                }
            } else if (trickInput && !offlineState.bidPhase) {
                e.preventDefault();
                const allTrickInputs = Array.from(app.querySelectorAll('.trick-input'));
                const currentIndex = allTrickInputs.findIndex(input => input === trickInput);
                const nextInput = allTrickInputs[currentIndex + 1];

                if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                } else if (allTricksEntered(offlineState) && validateTricksTotal(offlineState)) {
                    submitRoundResultsOffline();
                }
            }
        }

        function handleAppInput(e) {
            if (currentMode !== 'offline') return;

            const target = e.target;
            const bidInput = target.closest('.bid-input');
            const trickInput = target.closest('.trick-input');

            if (bidInput && offlineState.gameStarted && offlineState.bidPhase) {
                const player = bidInput.getAttribute('data-player');
                const value = bidInput.value;
                if (player) handleBidChangeOffline(player, value);
            } else if (trickInput && offlineState.gameStarted && !offlineState.bidPhase) {
                const player = trickInput.getAttribute('data-player');
                const value = trickInput.value;
                if (player) handleTricksChangeOffline(player, value);
            }
        }

        function renderApp() {
            let newHtml = '';
            let currentState = {};

            if (currentMode === 'entry') {
                newHtml = renderEntryScreen();
            } else if (currentMode === 'offline') {
                currentState = offlineState;
                if (!currentState.gameStarted) newHtml = renderPlayerSetup(currentState);
                else newHtml = renderGameplay(currentState);
            } else {
                newHtml = '<div class="card"><p>Error: Invalid application state.</p></div>';
            }

            // Don't rerender if the HTML hasn't changed - prevents jitter
            if (newHtml === previousHtml) {
                return;
            }
            
            // More efficient DOM update strategy to minimize flicker
            // Create a temporary div to parse the HTML
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = newHtml;
            
            // Cache active element before DOM update
            const activeElement = document.activeElement;
            const activeId = activeElement ? activeElement.id : null;
            const activeDataPlayer = activeElement ? activeElement.getAttribute('data-player') : null;
            const activeSelectionStart = activeElement && 'selectionStart' in activeElement ? activeElement.selectionStart : null;
            const activeSelectionEnd = activeElement && 'selectionEnd' in activeElement ? activeElement.selectionEnd : null;
            
            // Update the DOM
            app.innerHTML = newHtml;
            previousHtml = newHtml;
            
            // Try to restore focus with selection if possible
            if (activeId) {
                const newActiveElement = document.getElementById(activeId);
                if (newActiveElement) {
                    newActiveElement.focus();
                    if (activeSelectionStart !== null && activeSelectionEnd !== null && 'selectionStart' in newActiveElement) {
                        newActiveElement.selectionStart = activeSelectionStart;
                        newActiveElement.selectionEnd = activeSelectionEnd;
                    }
                }
            } else if (activeDataPlayer) {
                const newActiveElements = document.querySelectorAll(`[data-player="${activeDataPlayer}"]`);
                if (newActiveElements.length > 0) {
                    newActiveElements[0].focus();
                    if (activeSelectionStart !== null && activeSelectionEnd !== null && 'selectionStart' in newActiveElements[0]) {
                        newActiveElements[0].selectionStart = activeSelectionStart;
                        newActiveElements[0].selectionEnd = activeSelectionEnd;
                    }
                }
            }
            
            applyPostRenderFocus(currentState);

            // Always update validation/buttons after render for the active offline game
            if (currentMode === 'offline') {
                 updateValidationAndButtons();
                 if (currentState.gameStarted && currentState.currentRound <= 14) {
                    setTimeout(() => checkUpcomingElimination(currentState), 0);
                 }
            }
        }

        function applyPostRenderFocus(currentState) {
            // Preserve the currently focused element
            const activeElementId = document.activeElement ? document.activeElement.id : '';
            const activeElementSelector = document.activeElement ? 
                (document.activeElement.getAttribute('data-player') ? 
                    `.${document.activeElement.classList[0]}[data-player="${document.activeElement.getAttribute('data-player')}"]` : 
                    '') : 
                '';
            const hadFocus = document.activeElement && 
                (document.activeElement.classList.contains('bid-input') || 
                 document.activeElement.classList.contains('trick-input'));
            const selectionStart = hadFocus ? document.activeElement.selectionStart : null;
            const selectionEnd = hadFocus ? document.activeElement.selectionEnd : null;

            // Try to restore focus to the same element
            if (hadFocus && activeElementSelector) {
                const elementToFocus = document.querySelector(activeElementSelector);
                if (elementToFocus) {
                    elementToFocus.focus();
                    if (selectionStart !== null && selectionEnd !== null) {
                        elementToFocus.selectionStart = selectionStart;
                        elementToFocus.selectionEnd = selectionEnd;
                    } else {
                        elementToFocus.select();
                    }
                    return; // Exit early - we've restored focus
                }
            } else if (activeElementId) {
                const elementToFocus = document.getElementById(activeElementId);
                if (elementToFocus) {
                    elementToFocus.focus();
                    return; // Exit early - we've restored focus
                }
            }
            
            // Default focus behavior if we can't restore previous focus
            if (currentMode === 'entry') {
                 const offlineBtn = document.getElementById('select-offline-btn');
                 if (offlineBtn) offlineBtn.focus();
            } else if (currentMode === 'offline') {
                 if (!currentState.gameStarted) {
                    const playerNameInput = document.getElementById('player-name');
                    if (playerNameInput) playerNameInput.focus();
                 } else if (currentState.bidPhase && currentState.currentRound <= 14) {
                    const firstInput = document.querySelector('.bid-input:not([disabled])'); // Focus first *enabled* bid input
                    if (firstInput && (firstInput.value === '' || firstInput.value === null)) firstInput.focus();
                 } else if (!currentState.bidPhase && currentState.currentRound <= 14) {
                    const firstInput = document.querySelector('.trick-input');
                    if (firstInput && (firstInput.value === '' || firstInput.value === null)) firstInput.focus();
                 }
            }
            
            // Ensure back-to-menu button has a direct event listener as a fallback
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            if (backToMenuBtn) {
                // Remove any existing listeners to prevent duplicates
                backToMenuBtn.removeEventListener('click', goBackToEntry);
                // Add a fresh listener
                backToMenuBtn.addEventListener('click', goBackToEntry);
            }
        }

        function updateValidationAndButtons() {
            if (currentMode !== 'offline') return;

            const state = offlineState;
            if (!state || !state.gameStarted || state.currentRound > 14) return; // Only run if in a started game

            const totalBids = calculateTotalBids(state.bids, state.players);
            const totalTricks = calculateTotalTricks(state.tricks, state.players);
            const players = state.players || [];

            // --- Update Bid Info/Warning ---
            const bidInfoEl = document.getElementById('bid-info');
            if (bidInfoEl && state.bidPhase) {
                if (allPlayersHaveBid(state)) {
                    if (totalBids === state.currentRound) {
                        bidInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total bids cannot equal ${state.currentRound} (currently ${totalBids}).`;
                        bidInfoEl.className = 'game-info bid-warning';
                    } else {
                        bidInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Bids: Total ${totalBids}`;
                        bidInfoEl.className = 'game-info bid-ok';
                    }
                } else {
                    const waitingFor = players.filter(p => !state.bids || state.bids[p] === undefined || state.bids[p] === null);
                    const waitingText = waitingFor.length > 0 ? ` Waiting for ${waitingFor.length > 2 ? waitingFor.length + ' players' : waitingFor.map(escapeHtml).join(' & ')}.` : '';
                    bidInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total bids: ${totalBids} / ${state.currentRound}.${waitingText}`;
                    bidInfoEl.className = 'game-info';
                }
            }

            // --- Update Trick Info/Warning ---
            const trickInfoEl = document.getElementById('trick-info');
            if (trickInfoEl && !state.bidPhase) {
                if (allPlayersHaveTricks(state)) {
                    if (totalTricks !== state.currentRound) {
                        trickInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total hands must equal ${state.currentRound} (currently ${totalTricks})`;
                        trickInfoEl.className = 'game-info trick-warning';
                    } else {
                        trickInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Hands: Total ${totalTricks}`;
                        trickInfoEl.className = 'game-info trick-ok';
                    }
                } else {
                    const waitingFor = players.filter(p => !state.tricks || state.tricks[p] === undefined || state.tricks[p] === null);
                    const waitingText = waitingFor.length > 0 ? ` Waiting for ${waitingFor.length > 2 ? waitingFor.length + ' players' : waitingFor.map(escapeHtml).join(' & ')}.` : '';
                    trickInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total hands: ${totalTricks} / ${state.currentRound}.${waitingText}`;
                    trickInfoEl.className = 'game-info';
                }
            }

            // --- Update Button States ---
            const submitBidsBtn = document.getElementById('submit-bids-btn');
            if (submitBidsBtn) {
                submitBidsBtn.disabled = !allBidsEntered(state);
            }
            const submitResultsBtn = document.getElementById('submit-results-btn');
            if (submitResultsBtn) {
                submitResultsBtn.disabled = !(allTricksEntered(state) && validateTricksTotal(state));
            }
        }

        // --- Rendering Components ---

        function renderEntryScreen() {
            // Check if there's a saved offline game
            const hasSavedGame = hasSavedOfflineGame();
            const offlineButtonText = hasSavedGame ? 
                `<i class="fas fa-undo"></i> Continue Offline Game` : 
                `<i class="fas fa-play"></i> Start Offline Game`;
            
            return `
                <div class="card mode-selection-container">
                    <h2><i class="fas fa-dice"></i> Start a Game</h2>
                    <div class="card">
                        <h3><i class="fas fa-user-friends"></i> Play Offline</h3>
                        <p>Play solo or pass the device around. Game progress is saved locally in your browser.</p>
                        <button id="select-offline-btn" class="btn-full">${offlineButtonText}</button>
                        <button id="handoff-import-btn" class="btn-small" style="margin-top:0.5rem;"><i class="fas fa-qrcode"></i> Import from QR</button>
                    </div>
                </div>
            `;
        }


        function renderPlayerSetup(currentState) {
             const players = currentState.players || [];

             return `
                <div class="card">
                  <h2><i class="fas fa-users-cog"></i> Player Setup</h2>

                   <div class="input-group">
                     <div class="input-with-button">
                       <input type="text" id="player-name" placeholder="Enter player name" aria-label="Player name">
                       <button class="btn-add" id="add-player-btn"><i class="fas fa-plus"></i> Add Player</button>
                     </div>
                   </div>

                   ${players.length > 0 ? `
                     <div>
                       <h3><i class="fas fa-list-ul"></i> Current Players (${players.length})</h3>
                       <div class="player-list">
                         ${players.map((player, idx) => `
  <div class="player-item">
    <span class="player-name">
      ${escapeHtml(player)}
      ${idx === 0 ? '<span class="dealer-badge"><i class="fas fa-crown"></i> Dealer</span>' : ''}
    </span>
    <div style="display: flex; gap: 0.25rem; align-items: center;">
      <button class="btn-move-up" data-player="${escapeHtml(player)}" ${idx === 0 ? 'disabled' : ''} aria-label="Move ${escapeHtml(player)} up" tabindex="0" title="Move up">
        <i class="fas fa-arrow-up"></i>
      </button>
      <button class="btn-move-down" data-player="${escapeHtml(player)}" ${idx === players.length - 1 ? 'disabled' : ''} aria-label="Move ${escapeHtml(player)} down" tabindex="0" title="Move down">
        <i class="fas fa-arrow-down"></i>
      </button>
      <button class="btn-remove" data-player="${escapeHtml(player)}" aria-label="Remove ${escapeHtml(player)}">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
`).join('')}
                       </div>
                     </div>
                   ` : '<p style="text-align: center; color: var(--gray); font-size: 0.9rem; margin: 1.5rem 0;">No players added yet. Add 2 or more to start.</p>'}

                   <button
                     id="start-game-btn"
                     class="btn-full btn-green"
                     ${players.length < 2 ? 'disabled' : ''}
                   >
                     <i class="fas fa-play"></i>
                     ${players.length < 2
                       ? 'Need at least 2 players'
                       : `Start Game (${players.length} Players)`}
                   </button>
                   <div class="button-group" style="margin-top: 1.5rem; justify-content: center;">
                       <button id="back-to-menu-btn" class="btn-outline"><i class="fas fa-arrow-left"></i> Back to Start</button>
                       <button id="handoff-import-btn" class="btn-small"><i class="fas fa-qrcode"></i> Import from QR</button>
                   </div>
                </div>
             `;
        }

        function renderGameplay(currentState) {
            // Offline gameplay UI
            let gameplayHtml = '';
            const currentRound = currentState.currentRound || 1;
            const players = currentState.players || [];
            const eliminatedPlayers = currentState.eliminatedPlayers || [];
            const scores = currentState.scores || {};
            const bids = currentState.bids || {};
            const tricks = currentState.tricks || {};
            const bidPhase = currentState.bidPhase === undefined ? true : currentState.bidPhase;
            const dealerIndex = (Number.isInteger(currentState.dealerIndex) && players.length > 0)
                ? ((currentState.dealerIndex % players.length) + players.length) % players.length
                : 0;
            const dealerName = players.length > 0 ? players[dealerIndex] : null;
            let orderedPlayers = [...players];
            if (players.length > 1) {
                const startingIndex = (dealerIndex + 1) % players.length;
                orderedPlayers = [];
                for (let i = 0; i < players.length; i++) {
                    orderedPlayers.push(players[(startingIndex + i) % players.length]);
                }
            }
            const startingBidder = orderedPlayers.length > 0 ? orderedPlayers[0] : null;
            const highlightLead = players.length > 1;

            // --- Round Input / Game Over ---
            if (currentRound <= 14) {
                const bidInfoHtml = bidPhase ? '<div id="bid-info" class="game-info"></div>' : '';
                const tricksInfoHtml = !bidPhase ? '<div id="trick-info" class="game-info"></div>' : '';
                gameplayHtml += `
                <div class="card">
                    <div class="flex-between" style="margin-bottom: 0.25rem;">
                    <h2><i class="fas fa-tasks"></i> Round ${currentRound} / 14</h2>
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <span class="game-status">${bidPhase ? 'Bidding Phase' : 'Enter Hands Won'}</span>
                        <div id="round-elimination-banner" style="display: none; position: static;" class="elimination-banner">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="round-elimination-message">Upcoming elimination</span>
                        </div>
                    </div>

                    ${bidPhase ? bidInfoHtml : tricksInfoHtml}

                    <div class="table-container">
                    <table>
                        <thead>
                        <tr>
                            <th>Player</th>
                            <th>Bid</th>
                            ${!bidPhase ? '<th>Hands Won</th>' : ''}
                            <th>Score</th>
                        </tr>
                        </thead>
                        <tbody>
                        ${orderedPlayers.map(player => {
                            const bidValue = bids[player] ?? '';
                            const trickValue = tricks[player] ?? '';
                            const isDealer = dealerName === player;
                            const isLeader = highlightLead && (startingBidder === player);
                            return `
                            <tr>
                            <td>
                                <span class="player-name">
                                    ${escapeHtml(player)}
                                    ${isDealer ? '<span class="dealer-badge"><i class="fas fa-crown"></i> Dealer</span>' : ''}
                                    ${isLeader ? '<span class="lead-badge"><i class="fas fa-hand-point-right"></i> Leads</span>' : ''}
                                </span>
                            </td>
                            <td>
                                ${bidPhase
                                ? `<input type="number" min="0" max="${currentRound}" value="${bidValue}"
                                    class="bid-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} bid"
                                    inputmode="numeric" pattern="[0-9]*">`
                                : `<span class="badge badge-blue">${bidValue === '' || bidValue === null ? '?' : bidValue}</span>`}
                            </td>
                            ${!bidPhase
                                ? `<td class="trick-value">
                                    <input type="number" min="0" max="14" value="${trickValue}"
                                    class="trick-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} hands won"
                                    inputmode="numeric" pattern="[0-9]*">
                                </td>`
                                : ''}
                            <td><span class="score-value">${scores[player] || 0}</span></td>
                            </tr>
                        `}).join('')}
                        ${eliminatedPlayers.map(player => `
                                <tr class="eliminated-player">
                                <td>${escapeHtml(player)} <i class="fas fa-user-slash"></i></td>
                                <td>${bids[player] ?? '-'}</td>
                                ${!bidPhase ? `<td>${tricks[player] ?? '-'}</td>` : ''}
                                <td>${scores[player] || 0}</td>
                                </tr>
                            `).join('')}
                         ${players.length === 0 && eliminatedPlayers.length === 0 ? '<tr><td colspan="4" style="text-align:center; color: var(--gray);">No players in game.</td></tr>' : ''}
                        </tbody>
                    </table>
                    </div>

                    ${bidPhase
                    ? `<button id="submit-bids-btn" class="btn-full"><i class="fas fa-check-circle"></i> Confirm Bids</button>`
                    : `<button id="submit-results-btn" class="btn-full btn-green"><i class="fas fa-flag-checkered"></i> Submit Round ${currentRound} Results</button>`
                    }
                </div>
                `;
            } else { // Game Over
                 const winners = getWinners(currentState);
                 gameplayHtml += `
                    <div class="card">
                        <h2><i class="fas fa-trophy"></i> Game Over!</h2>
                        ${winners.length > 0
                        ? `<div class="winner-display">
                            <h3>${winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h3>
                            <div class="winner-name">
                                <i class="fas fa-crown"></i> ${winners.map(escapeHtml).join(' & ')}
                            </div>
                            <p>${scores[winners[0]] || 0} points</p>
                            </div>`
                        : '<p style="text-align:center; color: var(--gray);">Could not determine winner.</p>'}

                        <button id="reset-game-btn" class="btn-full btn-red">
                           <i class="fas fa-power-off"></i> Start New Game
                        </button>
                         <button id="back-to-menu-btn" class="btn-full btn-outline" style="margin-top: 0.75rem;">
                            <i class="fas fa-arrow-left"></i> Back to Start
                        </button>
                    </div>
                 `;
            }

            // --- Scoreboard ---
             const allPlayersForScoreboard = [...new Set([...(currentState.players || []), ...(currentState.eliminatedPlayers || [])])];
             const sortedPlayers = getSortedPlayers(scores, allPlayersForScoreboard);

            gameplayHtml += `
                <div class="card">
                <h2><i class="fas fa-clipboard-list"></i> Scoreboard</h2>
                <div class="table-container">
                    <table>
                    <thead><tr><th>Rank</th><th>Player</th><th>Score</th></tr></thead>
                    <tbody>
                        ${sortedPlayers.map((player, index) => {
                            const rank = index + 1;
                            const isEliminated = eliminatedPlayers.includes(player);
                            const isWinner = currentRound > 14 && getWinners(currentState).includes(player);
                            let medal = '';
                            if (isWinner && rank === 1) medal = '<i class="fas fa-medal" style="color: #d4af37;"></i>';
                            else if (currentRound > 14 && rank === 2) medal = '<i class="fas fa-medal" style="color: #c0c0c0;"></i>';
                            else if (currentRound > 14 && rank === 3) medal = '<i class="fas fa-medal" style="color: #cd7f32;"></i>';
                            return `
                        <tr class="${isWinner ? 'winner-row' : ''} ${isEliminated ? 'eliminated-player' : ''}">
                            <td>${rank} ${medal}</td>
                            <td>${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</td>
                            <td>${scores[player] || 0}</td>
                        </tr>`;
                        }).join('')}
                         ${sortedPlayers.length === 0 ? '<tr><td colspan="3" style="text-align:center; color: var(--gray);">No players on scoreboard yet.</td></tr>' : ''}
                    </tbody>
                    </table>
                </div>
                </div>

                ${currentRound <= 14 ? `
                    <div class="flex-between">
                    <div class="button-group">
                         <button id="undo-round-btn" class="btn-outline"><i class="fas fa-undo-alt"></i> Undo Round</button>
                         <button id="leave-game-btn" class="btn-leave-game"><i class="fas fa-sign-out-alt"></i> Leave</button>
                         <button id="reset-game-btn" class="btn-red"><i class="fas fa-power-off"></i> Reset Game</button>
                         <button id="handoff-qr-btn" class="btn-small"><i class="fas fa-qrcode"></i> Hand-off via QR</button>
                    </div>
                    <p>Round ${currentRound} / 14</p>
                    </div>
                    ` : ''}
            `;

            return gameplayHtml;
        }

        function renderCompletedGames() {
            const entries = (localHistory || []).map((game, index) => ({ game, index }))
                .filter(entry => entry.game.mode === undefined || entry.game.mode === null || entry.game.mode === 'offline');

            if (entries.length === 0) {
                completedGamesList.innerHTML = '<div class="no-games"><i class="fas fa-folder-open"></i> No completed games yet</div>';
                return;
            }

            completedGamesList.innerHTML = entries.slice().reverse().map(({ game, index }) => {
                game.eliminatedPlayers = game.eliminatedPlayers || [];
                const allParticipants = [...new Set([...(game.players || []), ...game.eliminatedPlayers])];
                const elimCount = game.eliminatedPlayers.length ? `<span style="color: var(--danger)"><i class="fas fa-user-slash"></i> ${game.eliminatedPlayers.length}</span>` : '';
                return `<div class="completed-game-item" data-game-index="${index}">
                                <div><i class="fas fa-calendar-alt"></i> ${new Date(game.date).toLocaleDateString()} ${new Date(game.date).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}</div>
                                <div class="game-winner"><i class="fas fa-trophy"></i> ${game.winners.map(escapeHtml).join(' & ')}</div>
                                <div class="game-score"><i class="fas fa-star"></i> ${game.score} points</div>
                                <div style="font-size: 0.8rem;">
                                <i class="fas fa-users"></i> ${allParticipants.length} Players ${elimCount ? `(${elimCount} Eliminated)` : ''}
                                </div>
                            </div>`;
            }).join('');
        }

        // --- Offline Mode Logic ---

        function getDefaultOfflineState() {
            return {
                players: [],
                gameStarted: false,
                currentRound: 1,
                dealerIndex: 0,
                bids: {},
                tricks: {},
                scores: {},
                bidPhase: true,
                roundHistory: [], // Specific to offline for undo
                eliminatedPlayers: []
            };
        }

        function loadOfflineState() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (savedState) {
                try {
                    offlineState = JSON.parse(savedState);
                    // Ensure all default keys exist for compatibility
                    offlineState = { ...getDefaultOfflineState(), ...offlineState };
                    const totalPlayers = offlineState.players.length;
                    if (!Number.isInteger(offlineState.dealerIndex) || totalPlayers === 0) {
                        offlineState.dealerIndex = 0;
                    } else {
                        const normalizedIndex = ((offlineState.dealerIndex % totalPlayers) + totalPlayers) % totalPlayers;
                        offlineState.dealerIndex = offlineState.players[normalizedIndex] === undefined ? 0 : normalizedIndex;
                    }
                    console.log('Offline game state loaded.');
                } catch (err) {
                    console.error('Error loading offline game state:', err);
                    offlineState = getDefaultOfflineState();
                    localStorage.removeItem(LOCAL_STORAGE_OFFLINE_KEY);
                }
            } else {
                offlineState = getDefaultOfflineState();
                console.log('No saved offline game state found, using default.');
            }
        }

        function saveOfflineState() {
            try {
                localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(offlineState));
            } catch (err) {
                console.error('Error saving offline game state:', err);
            }
        }

        function addPlayerOffline() {
            const playerNameInput = document.getElementById('player-name');
            if (!playerNameInput) return;
            let playerName = playerNameInput.value.trim();
            if (playerName.length > 0) playerName = playerName.charAt(0).toUpperCase() + playerName.slice(1);

            if (playerName && !offlineState.players.includes(playerName)) {
                if (offlineState.players.length >= MAX_PLAYERS) { alert(`Maximum of ${MAX_PLAYERS} players allowed.`); return; }
                offlineState.players.push(playerName);
                if (offlineState.players.length === 1) {
                    offlineState.dealerIndex = 0;
                }
                offlineState.scores[playerName] = 0; // Initialize score
                playerNameInput.value = '';
                saveOfflineState();
                renderApp();
            } else if (offlineState.players.includes(playerName)) {
                alert(`Player "${escapeHtml(playerName)}" already exists!`);
                playerNameInput.select();
            } else {
                playerNameInput.focus();
            }
        }

        function removePlayerOffline(playerToRemove) {
            offlineState.players = offlineState.players.filter(p => p !== playerToRemove);
            delete offlineState.scores[playerToRemove];
            delete offlineState.bids[playerToRemove];
            delete offlineState.tricks[playerToRemove];
            const remainingPlayers = offlineState.players.length;
            if (remainingPlayers === 0) {
                offlineState.dealerIndex = 0;
            } else if (offlineState.dealerIndex >= remainingPlayers) {
                offlineState.dealerIndex = remainingPlayers - 1;
            }
            // Clear from history if needed? Maybe not for offline.
            saveOfflineState();
            renderApp();
        }

        function startGameOffline() {
            if (offlineState.players.length < 2) { alert("Need at least 2 players."); return; }
            offlineState.gameStarted = true;
            offlineState.currentRound = 1;
            offlineState.dealerIndex = 0;
            offlineState.bidPhase = true;
            offlineState.bids = {};
            offlineState.tricks = {};
            offlineState.eliminatedPlayers = [];
            offlineState.roundHistory = []; // Reset history
            offlineState.players.forEach(p => { offlineState.scores[p] = 0; });
            saveOfflineState();
            renderApp();
            checkUpcomingElimination(offlineState);
        }

         function handleBidChangeOffline(player, value) {
            const maxBid = offlineState.currentRound;
            const bidValue = value === '' ? undefined : Math.min(Math.max(0, parseInt(value) || 0), maxBid);
            offlineState.bids[player] = bidValue;
            saveOfflineState();
            updateValidationAndButtons(); // Faster UI feedback without full re-render
         }

         function handleTricksChangeOffline(player, value) {
            const tricksValue = value === '' ? undefined : Math.min(Math.max(0, parseInt(value) || 0), 14);
            offlineState.tricks[player] = tricksValue;
            saveOfflineState();
            updateValidationAndButtons();
         }

         function submitBidsOffline() {
             if (!allBidsEntered(offlineState)) {
                 alert("Please ensure all players have entered a valid bid, and the total bids do not equal the current round number."); return;
             }
             offlineState.bidPhase = false;
             offlineState.tricks = {}; // Clear tricks for this phase
             offlineState.players.forEach(p => offlineState.tricks[p] = undefined); // Explicitly undefined
             saveOfflineState();
             renderApp();
         }

         function submitRoundResultsOffline() {
            if (!allTricksEntered(offlineState) || !validateTricksTotal(offlineState)) {
                alert("Please enter hands won for all players, and ensure the total equals the current round number."); return;
            }

            // Save current state for undo
            offlineState.roundHistory.push(JSON.parse(JSON.stringify({
                currentRound: offlineState.currentRound,
                bids: offlineState.bids,
                tricks: offlineState.tricks,
                scores: offlineState.scores,
                bidPhase: offlineState.bidPhase,
                eliminatedPlayers: [...offlineState.eliminatedPlayers],
                players: [...offlineState.players],
                dealerIndex: offlineState.dealerIndex
             })));

            const activePlayersBefore = [...offlineState.players];
            const totalBefore = activePlayersBefore.length;
            const dealerIndexBefore = (totalBefore > 0 && Number.isInteger(offlineState.dealerIndex))
                ? ((offlineState.dealerIndex % totalBefore) + totalBefore) % totalBefore
                : 0;
            const currentDealerName = totalBefore > 0 ? activePlayersBefore[dealerIndexBefore] : null;
            const dealerRotationCandidates = [];
            if (totalBefore > 1) {
                for (let offset = 1; offset < totalBefore; offset++) {
                    dealerRotationCandidates.push(activePlayersBefore[(dealerIndexBefore + offset) % totalBefore]);
                }
            }

             // Calculate scores
             let newEliminatedPlayer = null;
             offlineState.players.forEach(player => {
                 const bid = offlineState.bids[player];
                 const tricks = offlineState.tricks[player];
                 if (typeof bid === 'number' && typeof tricks === 'number') {
                     let roundScore = (bid === tricks) ? (bid === 0 ? 10 : tricks + (10 * bid)) : tricks;
                     offlineState.scores[player] = (offlineState.scores[player] || 0) + roundScore;
                 }
             });

             if (offlineState.currentRound < 14) {
                 offlineState.currentRound++;
                 offlineState.bidPhase = true;

                 newEliminatedPlayer = checkElimination(offlineState); // Check for elimination
                 if (newEliminatedPlayer) {
                     offlineState.eliminatedPlayers.push(newEliminatedPlayer);
                     offlineState.players = offlineState.players.filter(p => p !== newEliminatedPlayer);
                 }
                 const playersAfterElimination = offlineState.players;

                 offlineState.bids = {}; // Reset bids/tricks for next round
                 offlineState.tricks = {};
                 playersAfterElimination.forEach(p => { offlineState.bids[p] = undefined; offlineState.tricks[p] = undefined; });

                 if (playersAfterElimination.length > 0) {
                     let nextDealerName = null;
                     for (const candidate of dealerRotationCandidates) {
                         if (playersAfterElimination.includes(candidate)) {
                             nextDealerName = candidate;
                             break;
                         }
                     }
                     if (!nextDealerName) {
                         if (currentDealerName && playersAfterElimination.includes(currentDealerName)) {
                             nextDealerName = currentDealerName;
                         } else {
                             nextDealerName = playersAfterElimination[0];
                         }
                     }
                     const newIndex = playersAfterElimination.indexOf(nextDealerName);
                     offlineState.dealerIndex = newIndex === -1 ? 0 : newIndex;
                 } else {
                     offlineState.dealerIndex = 0;
                 }

                 checkUpcomingElimination(offlineState);

             } else {
                 offlineState.currentRound = 15; // Game over
                 saveCompletedGameToLocal(offlineState);
                 localStorage.removeItem(LOCAL_STORAGE_OFFLINE_KEY); // Clear current game state after saving history
             }

             saveOfflineState(); // Save potentially modified state (elimination, next round)
             renderApp();
         }

        function resetGameOffline() {
            if (confirm("Are you sure you want to start a new offline game? This will clear the current offline game progress.")) {
                offlineState = getDefaultOfflineState();
                saveOfflineState();
                previousHtml = ''; // Force re-render
                renderApp();
                hideEliminationBanner();
            }
        }

        function undoRoundOffline() {
             if (offlineState.roundHistory && offlineState.roundHistory.length > 0) {
                if (confirm("Are you sure you want to undo the last round?")) {
                    const prevState = offlineState.roundHistory.pop();

                    // Restore previous state values
                    offlineState.currentRound = prevState.currentRound;
                    offlineState.bids = prevState.bids;
                    offlineState.scores = prevState.scores;
                    offlineState.eliminatedPlayers = prevState.eliminatedPlayers; // Restore eliminated list

                    // Restore active players list based on who had scores in the previous state
                    // and remove players who were only eliminated *after* that round
                    const previousActivePlayers = Array.isArray(prevState.players)
                        ? prevState.players
                        : Object.keys(prevState.scores).filter(p => !prevState.eliminatedPlayers.includes(p));
                    offlineState.players = [...previousActivePlayers];

                    if (Number.isInteger(prevState.dealerIndex)) {
                        const count = offlineState.players.length;
                        offlineState.dealerIndex = count > 0
                            ? ((prevState.dealerIndex % count) + count) % count
                            : 0;
                    } else {
                        offlineState.dealerIndex = 0;
                    }


                    offlineState.bidPhase = true; // Always go back to bidding phase
                    offlineState.tricks = {}; // Clear tricks for the restored round
                     offlineState.players.forEach(p => offlineState.tricks[p] = undefined);

                    saveOfflineState();
                    renderApp();
                    checkUpcomingElimination(offlineState); // Recheck eliminations
                }
             } else {
                 alert("No rounds to undo.");
             }
        }

        // --- Shared Helper & Validation Functions ---

        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                 .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;").replace(/'/g, "&#39;");
        }

        function applyTheme(theme) {
            const newTheme = (theme === 'dark') ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            darkModeToggle.checked = newTheme === 'dark';
            localStorage.setItem(LOCAL_STORAGE_THEME_KEY, newTheme);
            console.log("Theme applied:", newTheme);
        }

        function calculateTotalBids(bids, players) {
            return (players || []).reduce((sum, p) => {
                const bid = bids && bids[p];
                return sum + (bid === null || bid === undefined ? 0 : Number(bid) || 0);
            }, 0);
        }

        function calculateTotalTricks(tricks, players) {
            return (players || []).reduce((sum, p) => {
                const trick = tricks && tricks[p];
                return sum + (trick === null || trick === undefined ? 0 : Number(trick) || 0);
            }, 0);
        }

        function allPlayersHaveBid(currentState) {
            const players = currentState.players || [];
            if (players.length === 0) return false;
            return players.every(p => currentState.bids && currentState.bids[p] !== undefined && currentState.bids[p] !== null);
        }

        function allPlayersHaveTricks(currentState) {
             const players = currentState.players || [];
             if (players.length === 0) return false;
             return players.every(p => currentState.tricks && currentState.tricks[p] !== undefined && currentState.tricks[p] !== null);
        }

        function allBidsEntered(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || !currentState.bidPhase || players.length === 0) return false;
            if (!allPlayersHaveBid(currentState)) return false;
            const totalBids = calculateTotalBids(currentState.bids, players);
            return totalBids !== currentState.currentRound;
        }

        function allTricksEntered(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || currentState.bidPhase || players.length === 0) return false;
            return allPlayersHaveTricks(currentState);
        }

        function validateTricksTotal(currentState) {
            const players = currentState.players || [];
            if (!currentState.gameStarted || currentState.bidPhase || players.length === 0) return false;
            const totalTricks = calculateTotalTricks(currentState.tricks, players);
            return totalTricks === currentState.currentRound;
        }

        function getWinners(currentState) {
             if (!currentState || !currentState.gameStarted || currentState.currentRound <= 14) return [];
             const scores = currentState.scores || {};
             if (Object.keys(scores).length === 0) return [];

             const finalPlayers = [...new Set([...(currentState.players || []), ...(currentState.eliminatedPlayers || [])])];
             if (finalPlayers.length === 0) return [];

             let highestScore = -Infinity;
             finalPlayers.forEach(player => { highestScore = Math.max(highestScore, scores[player] || 0); });
             if (highestScore === -Infinity) return [];

             return finalPlayers.filter(player => (scores[player] || 0) === highestScore);
        }

        function getSortedPlayers(scores, playerList) {
             if (!playerList || playerList.length === 0) return [];
             const scoresObj = scores || {};
             return [...playerList]
                .map(player => ({ name: player, score: scoresObj[player] || 0 }))
                .sort((a, b) => b.score - a.score)
                .map(p => p.name);
        }

        function checkElimination(currentState) {
             const players = currentState.players || [];
             const scores = currentState.scores || {};
             const currentRound = currentState.currentRound || 1;

             if (players.length * currentRound > ELIMINATION_THRESHOLD && players.length > 1) {
                 let lowestScore = Infinity;
                 players.forEach(p => { lowestScore = Math.min(lowestScore, scores[p] || 0); });

                 const lowestPlayers = players.filter(p => (scores[p] || 0) === lowestScore);
                 if (lowestPlayers.length > 0) {
                    const playerToEliminate = lowestPlayers[0];
                    alert(`Player "${escapeHtml(playerToEliminate)}" eliminated! (Lowest score: ${lowestScore})`);
                    return playerToEliminate;
                 }
             }
             return null; // No elimination
        }

        function checkUpcomingElimination(currentState) {
            if (!currentState || !currentState.gameStarted || currentState.currentRound > 14 || !currentState.players || currentState.players.length < 2) {
                hideEliminationBanner(); 
                return;
            }
            
            // Check if elimination will happen in any future round
            let eliminationRound = null;
            for (let futureRound = currentState.currentRound; futureRound <= 14; futureRound++) {
                if (currentState.players.length * futureRound > ELIMINATION_THRESHOLD) {
                    eliminationRound = futureRound;
                    break;
                }
            }
            
            // Only update DOM if needed
            if (eliminationRound) {
                showEliminationBanner(eliminationRound);
            } else {
                hideEliminationBanner();
            }
        }

        function showEliminationBanner(round) {
            const roundMessage = document.getElementById('round-elimination-message');
            const roundBanner = document.getElementById('round-elimination-banner');
            if (roundMessage && roundBanner) {
                roundMessage.textContent = `Elimination at Round ${round}`;
                // Always keep the element in DOM but control visibility with opacity
                if (roundBanner.style.display === 'none') {
                    roundBanner.style.display = 'flex';
                }
            }
            // Keep fixed banner hidden
            const origBanner = document.getElementById('elimination-banner');
            if (origBanner) origBanner.style.display = 'none';
        }
        
        function hideEliminationBanner() {
            const origBanner = document.getElementById('elimination-banner');
            if (origBanner) origBanner.style.display = 'none';
            
            const roundBanner = document.getElementById('round-elimination-banner');
            if (roundBanner) roundBanner.style.display = 'none';
        }

        function copyGameIdToClipboard(gameId, displayElement) {
             if (!navigator.clipboard) { alert("Clipboard not available."); return; }
             navigator.clipboard.writeText(gameId).then(() => {
                 const feedbackEl = displayElement.querySelector('.copy-feedback');
                 if (feedbackEl) {
                     feedbackEl.classList.add('visible');
                     setTimeout(() => feedbackEl.classList.remove('visible'), 1500);
                 }
             }).catch(err => { console.error('Failed to copy:', err); alert('Copy failed.'); });
        }

        function showQRCode(gameId) {
            const qrCodeModal = document.getElementById('qr-code-modal');
            const qrCodeContainer = document.getElementById('qr-code-container');
            const qrCodeClose = document.getElementById('qr-code-close');
            
            // Clear previous QR code
            qrCodeContainer.innerHTML = '';
            
            // Generate a QR code with just the game ID as plain text
            // This will allow the user to easily copy it after scanning
            const qrData = gameId;
            
            try {
                // Generate QR code with qrcodejs
                new QRCode(qrCodeContainer, {
                    text: qrData,
                    width: 250,
                    height: 250,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Add game ID display and copy button below QR code
                const infoContainer = document.createElement('div');
                infoContainer.style.marginTop = '1rem';
                infoContainer.style.textAlign = 'center';
                
                // Game ID display
                const gameIdDisplay = document.createElement('div');
                gameIdDisplay.style.fontFamily = 'monospace';
                gameIdDisplay.style.padding = '0.5rem';
                gameIdDisplay.style.backgroundColor = 'var(--light-alt)';
                gameIdDisplay.style.border = '1px solid var(--gray-light)';
                gameIdDisplay.style.borderRadius = 'var(--radius)';
                gameIdDisplay.style.marginBottom = '0.5rem';
                gameIdDisplay.style.wordBreak = 'break-all';
                gameIdDisplay.textContent = gameId;
                
                // Copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn-small';
                copyBtn.innerHTML = '<i class="far fa-copy"></i> Copy Game ID';
                copyBtn.style.margin = '0 auto';
                
                // Feedback element
                const feedbackEl = document.createElement('span');
                feedbackEl.className = 'copy-feedback';
                feedbackEl.id = `qr-copy-feedback-${gameId}`;
                feedbackEl.textContent = 'Copied!';
                feedbackEl.style.display = 'block';
                feedbackEl.style.marginTop = '0.5rem';
                
                // Add click handler for copy button
                copyBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(gameId).then(() => {
                        feedbackEl.classList.add('visible');
                        setTimeout(() => feedbackEl.classList.remove('visible'), 1500);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        alert('Copy failed.');
                    });
                });
                
                // Append elements
                infoContainer.appendChild(gameIdDisplay);
                infoContainer.appendChild(copyBtn);
                infoContainer.appendChild(feedbackEl);
                qrCodeContainer.appendChild(infoContainer);
                
                // Update instructions
                const instructionsDiv = document.querySelector('.qr-code-instructions');
                if (instructionsDiv) {
                    instructionsDiv.innerHTML = `
                        Scan this QR code with your phone's camera or QR scanner app,<br>
                        or copy the game ID manually to join the game.
                    `;
                }
            } catch (err) {
                console.error('Failed to generate QR code:', err);
                qrCodeContainer.innerHTML = '<p>QR code generation failed. Please try again.</p>';
            }
            
            // Show modal
            qrCodeModal.classList.add('active');
            
            // Add close handler
            qrCodeClose.onclick = function() {
                qrCodeModal.classList.remove('active');
            };
            
            // Close on background click
            qrCodeModal.onclick = function(e) {
                if (e.target === qrCodeModal) {
                    qrCodeModal.classList.remove('active');
                }
            };
        }

        // --- Local History Management ---
        function loadLocalHistory() {
            localHistory = JSON.parse(localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY)) || [];
            renderCompletedGames();
        }

        function saveCompletedGameToLocal(finalState) {
            const winners = getWinners(finalState);
            const completedGame = {
                mode: 'offline',
                gameId: null,
                date: new Date().toISOString(),
                winners: winners,
                score: winners.length > 0 ? (finalState.scores[winners[0]] || 0) : 0,
                players: [...(finalState.players || [])], // Active players at end
                finalScores: { ...(finalState.scores || {}) },
                eliminatedPlayers: [...(finalState.eliminatedPlayers || [])],
                wasReset: finalState.wasReset || false // Include reset flag if it exists
            };
            localHistory = JSON.parse(localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY)) || [];
            localHistory.push(completedGame);
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(localHistory));
            renderCompletedGames();
        }

        function showGameDetails(gameIndex) {
            const game = localHistory[gameIndex];
            if (!game) return;
            const gameDate = new Date(game.date);
            const formattedDate = `${gameDate.toLocaleDateString()} ${gameDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
            game.eliminatedPlayers = game.eliminatedPlayers || [];
            const allParticipants = [...new Set([...(game.players || []), ...game.eliminatedPlayers])];
            const sortedPlayers = getSortedPlayers(game.finalScores || {}, allParticipants);

            let content = `
                <div class="game-date"><i class="fas fa-calendar-alt"></i> ${formattedDate}</div>
                <div class="game-details-winners">
                <h4>${game.winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h4>
                <div class="winner-names">
                    <i class="fas fa-crown"></i> ${game.winners.map(escapeHtml).join(' & ')}
                    <span style="margin-left:auto;">${game.score} points</span>
                </div>
                </div>
                <h4>All Players (${allParticipants.length})</h4>
                <div class="player-scores-container">
                <div class="player-scores-header"><span>Player</span><span>Final Score</span></div>
                <div class="player-scores-list">
            `;
            sortedPlayers.forEach((player, index) => {
                const isWinner = game.winners.includes(player);
                const isEliminated = game.eliminatedPlayers.includes(player);
                const playerScore = game.finalScores[player] || 0;
                content += `
                <div class="player-score-item ${isWinner ? 'winner' : ''} ${isEliminated ? 'eliminated' : ''}">
                    <span class="player-score-name">${index + 1}. ${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</span>
                    <span class="player-score-value">${playerScore}</span>
                </div>`;
            });
            content += `</div></div>`;
            gameDetailsBody.innerHTML = content;
            gameDetailsModal.classList.add('active');
        }

        function closeGameDetailsModal() {
             gameDetailsModal.classList.remove('active');
             gameDetailsBody.innerHTML = ''; // Clear content
        }

        // --- Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js') // Ensure service-worker.js exists
                .then(reg => console.log('Service Worker registered:', reg.scope))
                .catch(err => console.error('Service Worker registration failed:', err));
            });
             navigator.serviceWorker.addEventListener('controllerchange', () => {
                 console.log('Service Worker updated.');
                 // Optional: Add prompt to reload window.location.reload();
             });

             // Add to Home Screen logic (optional but good for PWA)
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                console.log("`beforeinstallprompt` event was fired.");
                // Optionally, show a custom install button here
            });
             window.addEventListener('appinstalled', () => {
                 console.log('PWA was installed');
                 deferredPrompt = null;
            });
        }

        // --- Start the App ---
        initializeApp();

        // --- Hand-off QR Export/Import Logic ---
        function showHandoffQRModal() {
            const modal = document.getElementById('handoff-qr-modal');
            const container = document.getElementById('handoff-qr-container');
            const closeBtn = document.getElementById('handoff-qr-close');
            if (!modal || !container) return;
            container.innerHTML = '';
            
            // Get offline game state
            let stateStr = localStorage.getItem(LOCAL_STORAGE_OFFLINE_KEY);
            if (!stateStr) {
                container.innerHTML = '<p style="color:var(--danger);">No offline game to export.</p>';
                modal.classList.add('active');
                return;
            }
            
            try {
                // Parse and compress the game state for QR export
                const fullState = JSON.parse(stateStr);
                
                // Create a minimal state for hand-off (remove unnecessary data)
                const minimalState = {
                    players: fullState.players || [],
                    gameStarted: fullState.gameStarted || false,
                    currentRound: fullState.currentRound || 1,
                    bids: fullState.bids || {},
                    tricks: fullState.tricks || {},
                    scores: fullState.scores || {},
                    bidPhase: fullState.bidPhase !== false, // default true
                    eliminatedPlayers: fullState.eliminatedPlayers || []
                    // Note: We're excluding roundHistory to save space
                };
                
                const minimalStateStr = JSON.stringify(minimalState);
                // --- COMPRESSION ADDED HERE ---
                const compressed = LZString.compressToEncodedURIComponent(minimalStateStr);
                const qrData = '14HIGHZ:' + compressed;
                // --- END COMPRESSION ---
                
                // Check size before generating QR
                const dataSize = new Blob([qrData]).size;
                console.log(`QR data size: ${dataSize} bytes`);
                
                if (dataSize > 2900) { // Conservative limit
                    container.innerHTML = `
                        <div style="text-align: center; color: var(--danger); padding: 1rem;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                            <p><strong>Game data too large for QR code</strong></p>
                            <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                                Data size: ${dataSize} bytes (limit: ~2900 bytes)<br>
                                Try reducing player names or start a new game.
                            </p>
                            <button onclick="copyGameDataToClipboard()" style="margin-top: 1rem;" class="btn-small">
                                <i class="fas fa-copy"></i> Copy Game Data Instead
                            </button>
                        </div>
                    `;
                    
                    // Add the copy function to window for the button
                    window.copyGameDataToClipboard = function() {
                        navigator.clipboard.writeText(qrData).then(() => {
                            alert('Game data copied to clipboard! Share this text with the other player.');
                        }).catch(err => {
                            console.error('Copy failed:', err);
                            alert('Copy failed. Please try selecting and copying the data manually.');
                        });
                    };
                    
                    modal.classList.add('active');
                    return;
                }
                
                // Generate QR code with lower error correction for more data capacity
                new QRCode(container, {
                    text: qrData,
                    width: 250,
                    height: 250,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.L // Lower error correction = more data capacity
                });
                
                // Add data size info below QR code
                const infoDiv = document.createElement('div');
                infoDiv.style.marginTop = '1rem';
                infoDiv.style.fontSize = '0.8rem';
                infoDiv.style.color = 'var(--gray)';
                infoDiv.style.textAlign = 'center';
                infoDiv.innerHTML = `
                    Data size: ${dataSize} bytes<br>
                    <span style="color: var(--success);"> QR code generated successfully</span>
                `;
                container.appendChild(infoDiv);
                
            } catch (err) {
                console.error('QR generation error:', err);
                container.innerHTML = `
                    <div style="text-align: center; color: var(--danger); padding: 1rem;">
                        <i class="fas fa-times-circle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p><strong>QR code generation failed</strong></p>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                            Error: ${err.message || 'Unknown error'}<br>
                            Please try again or start a new game.
                        </p>
                    </div>
                `;
            }
            
            modal.classList.add('active');
            closeBtn.onclick = () => modal.classList.remove('active');
            modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('active'); };
        }

        function showHandoffImportModal() {
            const modal = document.getElementById('handoff-import-modal');
            const closeBtn = document.getElementById('handoff-import-close');
            const statusEl = document.getElementById('handoff-import-status');
            const qrReaderDiv = document.getElementById('handoff-qr-reader');
            if (!modal || !qrReaderDiv) return;
            statusEl.textContent = 'Position the QR code in the frame...';
            statusEl.style.color = 'var(--gray)';
            qrReaderDiv.innerHTML = '';
            modal.classList.add('active');
            let html5QrCode;
            
            // Function to process import data (QR only)
            function processImportData(decodedText, statusEl, html5QrCode, modal) {
                if (decodedText.startsWith('14HIGHZ:')) {
                    try {
                        const compressed = decodedText.slice(8);
                        const jsonStr = LZString.decompressFromEncodedURIComponent(compressed);
                        const parsed = JSON.parse(jsonStr);
                        
                        // Enhanced validation
                        if (parsed && 
                            Array.isArray(parsed.players) && 
                            typeof parsed.gameStarted === 'boolean' &&
                            typeof parsed.currentRound === 'number' &&
                            parsed.scores && typeof parsed.scores === 'object') {
                            
                            // Restore full game state with defaults for missing data
                            const fullState = {
                                players: parsed.players,
                                gameStarted: parsed.gameStarted,
                                currentRound: parsed.currentRound,
                                bids: parsed.bids || {},
                                tricks: parsed.tricks || {},
                                scores: parsed.scores || {},
                                bidPhase: parsed.bidPhase !== false, // default true
                                eliminatedPlayers: parsed.eliminatedPlayers || [],
                                roundHistory: [] // Reset history since we didn't transfer it
                            };
                            
                            localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(fullState));
                            statusEl.style.color = 'var(--success)';
                            statusEl.textContent = `Game imported! Found ${parsed.players.length} players, Round ${parsed.currentRound}. Loading...`;
                            
                            const closeAndLoad = () => {
                                setTimeout(() => {
                                    modal.classList.remove('active');
                                    selectMode('offline');
                                }, 800);
                            };
                            
                            if (html5QrCode) {
                                html5QrCode.stop().then(closeAndLoad).catch(closeAndLoad);
                            } else {
                                closeAndLoad();
                            }
                        } else {
                            statusEl.style.color = 'var(--danger)';
                            statusEl.textContent = 'Invalid game data format. Missing required fields.';
                            console.error('Invalid game data:', parsed);
                        }
                    } catch (err) {
                        statusEl.style.color = 'var(--danger)';
                        statusEl.textContent = 'Failed to decompress game data: ' + err.message;
                        console.error('Decompression error:', err);
                    }
                } else if (decodedText.startsWith('14HIGH:')) {
                    try {
                        const jsonStr = decodedText.slice(7);
                        const parsed = JSON.parse(jsonStr);
                        // Enhanced validation
                        if (parsed && 
                            Array.isArray(parsed.players) && 
                            typeof parsed.gameStarted === 'boolean' &&
                            typeof parsed.currentRound === 'number' &&
                            parsed.scores && typeof parsed.scores === 'object') {
                            // Restore full game state with defaults for missing data
                            const fullState = {
                                players: parsed.players,
                                gameStarted: parsed.gameStarted,
                                currentRound: parsed.currentRound,
                                bids: parsed.bids || {},
                                tricks: parsed.tricks || {},
                                scores: parsed.scores || {},
                                bidPhase: parsed.bidPhase !== false, // default true
                                eliminatedPlayers: parsed.eliminatedPlayers || [],
                                roundHistory: [] // Reset history since we didn't transfer it
                            };
                            localStorage.setItem(LOCAL_STORAGE_OFFLINE_KEY, JSON.stringify(fullState));
                            statusEl.style.color = 'var(--success)';
                            statusEl.textContent = `Game imported! Found ${parsed.players.length} players, Round ${parsed.currentRound}. Loading...`;
                            const closeAndLoad = () => {
                                setTimeout(() => {
                                    modal.classList.remove('active');
                                    selectMode('offline');
                                }, 800);
                            };
                            if (html5QrCode) {
                                html5QrCode.stop().then(closeAndLoad).catch(closeAndLoad);
                            } else {
                                closeAndLoad();
                            }
                        } else {
                            statusEl.style.color = 'var(--danger)';
                            statusEl.textContent = 'Invalid game data format. Missing required fields.';
                            console.error('Invalid game data:', parsed);
                        }
                    } catch (err) {
                        statusEl.style.color = 'var(--danger)';
                        statusEl.textContent = 'Failed to parse game data: ' + err.message;
                        console.error('Parse error:', err);
                    }
                } else {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'Not a 14-High! game QR code.';
                }
            }
            
            // Start QR scanner
            setTimeout(() => {
                if (typeof Html5Qrcode === 'undefined') {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'QR scanner not available.';
                    return;
                }
                
                html5QrCode = new Html5Qrcode("handoff-qr-reader");
                html5QrCode.start(
                    { facingMode: "environment" },
                    { fps: 10, qrbox: 250 },
                    (decodedText, decodedResult) => {
                        processImportData(decodedText, statusEl, html5QrCode, modal);
                    },
                    (errorMessage) => {
                        // Ignore frequent scan errors, but show camera issues
                        if (errorMessage.includes('Camera') || errorMessage.includes('Permission')) {
                            statusEl.style.color = 'var(--warning)';
                            statusEl.textContent = 'Camera issue: ' + errorMessage;
                        }
                    }
                ).catch(err => {
                    statusEl.style.color = 'var(--danger)';
                    statusEl.textContent = 'Camera error: ' + err.message;
                    console.error('Camera error:', err);
                });
            }, 100);
            
            // Close logic
            closeBtn.onclick = () => {
                modal.classList.remove('active');
                if (html5QrCode) html5QrCode.stop().catch(()=>{});
            };
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    if (html5QrCode) html5QrCode.stop().catch(()=>{});
                }
            };
        }

    </script>
</body>
</html>
